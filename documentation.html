
	<html>
		<head>
			<title>Monadic JS Documentation</title>
			<style>
				.module-header, .module-description {
					background-color: #EFEFEF;
				}

				.function-description {
					background-color: #DDD;
				}

				.module-header {
					border: 1px solid;
					border-radius: 5px;
					padding: 10px;
					margin: 10px 0 10px 0;
				}
				.module-name {
					font-weight: bold;
				}
				.module-description .module-name {
					font-size: 120%;
				}
				ul.module-functions {
					list-style: none;
				}
				.module-description {
					border: 1px solid;
					border-radius: 5px;
					padding: 10px;
					margin: 10px 0 10px 0;
				}
				.module-name, .module-author,
				.module-date {
					margin: 2px 0 2px 0;
				}
				.module-desc {
					margin: 10px 0 10px 20px;
				}

				.function-description {
					backgound-color: #EFEFEF;
					border: 1px dotted;
					border-radius: 5px;
					padding: 10px;
					margin: 5px 0 5px 0;
				}

				.function-desc {
					margin: 5px 0 5px 20px;
				}

				a:visited {
					color: #00F
				}

				a {
					text-decoration: none;
					border-bottom: 1px solid transparent;
					transition: all ease-in-out 0.5s;
				}

				a:hover {
					text-decoration: none;
					border-color: #00F;
				}

				.top-scroll {
					position: fixed;
					bottom: 0;
					right: 10px;
					font-weight: bold;
					font-size: 180%;
					border: 1px solid;
					border-radius: 5px;
					padding: 10px 20px;
					background-color: #EFEFEF;
					opacity: 0.8;
					cursor: pointer;
				}
			</style>
			<script type="text/javascript">
				window.onload = function() {
					var links = document.querySelectorAll('a');
					links.forEach(link => link.addEventListener('click', function(e) {
						e.preventDefault();
						var elm = this.href.substring(this.href.indexOf('#') + 1);
						scrollToItemId(elm, 2);
					}));

					document.querySelector('.top-scroll').addEventListener('click', function() {
						scrollToItemId('top', 2);
					});

					window.onscroll();
				}

				window.onscroll = function() {
					document.querySelector('.top-scroll').style.visibility = 
						document.body.scrollTop > 100 ? 'visible' : 'hidden';
				}

				function scrollToItemId(scrollToId, scrollTime) {
					scrollTime *= 1000;
			        var item = document.getElementById(scrollToId);

			        var from = document.body.scrollTop;
			        var to = item.offsetTop;

			        var startTime = Date.now();

				    function ease(k) {
				    	return 0.5 * (1 - Math.cos(Math.PI * k));
				    }

			        (function scroll() {
			        	var elapsed = (Date.now() - startTime) / scrollTime;
			        	if (elapsed > 1)
			        		elapsed = 1;
			        	var change = ease(elapsed);
			        	var currentPos = from + (to - from) * change;

			            document.body.scrollTop = currentPos;
			            if (currentPos !== to) {
			                requestAnimationFrame(scroll);
			            }
			            else {
			            	window.location.hash = '#' + scrollToId;
			            }
			        })();
			    }
			</script>
		</head>
		<body>
			<div class="project-header" id="top">
			<h1>Monadic JS Documentation</h1>
			</div>
			<div class="project-synopsis">
			<h2>Module List</h2>
			
		<div class="module-header">
			<div class="module-name">
			Module: <a href="#doc.module.MonadicJS.ArrayExtensions">MonadicJS.ArrayExtensions</a>
			</div>
			<ul class="module-functions">
				
			</ul>
		</div>
	
		<div class="module-header">
			<div class="module-name">
			Module: <a href="#doc.module.MonadicJS.FunctionExtensions">MonadicJS.FunctionExtensions</a>
			</div>
			<ul class="module-functions">
				
			<li>
				<a href="#doc.module.MonadicJS.FunctionExtensions.func.map">
					<b>map</b>
				</a> <b>::</b> (a &#8594; b) &#8594; (b &#8594; c) &#8594; a &#8594; c
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.FunctionExtensions.func.chain">
					<b>chain</b>
				</a> <b>::</b> (a &#8594; b) &#8594; (b &#8594; (a &#8594; c)) &#8594; a &#8594; c
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.FunctionExtensions.func.arrow">
					<b>arrow</b>
				</a> <b>::</b> Monad m &#8658; (a &#8594; m b) &#8594; (b &#8594; m c) &#8594; a &#8594; m c
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.FunctionExtensions.func.alt">
					<b>alt</b>
				</a> <b>::</b> Alternative f &#8658; (a &#8594; f b) &#8594; (a &#8594; f c) &#8594; a &#8594; f (b | c)
			</li>
		
			</ul>
		</div>
	
		<div class="module-header">
			<div class="module-name">
			Module: <a href="#doc.module.Monadic">Monadic</a>
			</div>
			<ul class="module-functions">
				
			</ul>
		</div>
	
		<div class="module-header">
			<div class="module-name">
			Module: <a href="#doc.module.Monadic.Utility">Monadic.Utility</a>
			</div>
			<ul class="module-functions">
				
			<li>
				<a href="#doc.module.Monadic.Utility.func.doM">
					<b>doM</b>
				</a> <b>::</b> Monad m &#8658; (() &#8594; Iterator) &#8594; m a
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Utility.func.when">
					<b>when</b>
				</a> <b>::</b> Applicative f &#8658; (bool, f ()) &#8594; f ()
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Utility.func.unless">
					<b>unless</b>
				</a> <b>::</b> Applicative f &#8658; (bool, f ()) &#8594; f ()
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Utility.func.guard">
					<b>guard</b>
				</a> <b>::</b> Alternative f &#8658; (bool, Type f) &#8594; f ()
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Utility.func.constant">
					<b>constant</b>
				</a> <b>::</b> a &#8594; () &#8594; a
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Utility.func.id">
					<b>id</b>
				</a> <b>::</b> a &#8594; a
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Utility.func.foldrM">
					<b>foldrM</b>
				</a> <b>::</b> Foldable t, Monad m &#8658; (Type m, (a, b) &#8594; m b) &#8594; b &#8594; t a &#8594; m b
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Utility.func.foldlM">
					<b>foldlM</b>
				</a> <b>::</b> Foldable t, Monad m &#8658; (Type m, (b, a) &#8594; m b) &#8594; b &#8594; t a &#8594; m b
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Utility.func.filterM">
					<b>filterM</b>
				</a> <b>::</b> Consable t, Applicative f &#8658; (Type f, (a &#8594; f bool)) &#8594; t a &#8594; f (t a)
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Utility.func.mapM">
					<b>mapM</b>
				</a> <b>::</b> Consable t, Applicative f &#8658; (Type f, (a &#8594; f b)) &#8594; t a &#8594; f (t b)
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Utility.func.all">
					<b>all</b>
				</a> <b>::</b> Applicative f &#8658; (Type f, [f a]) &#8594; f [a]
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Utility.func.replicateM">
					<b>replicateM</b>
				</a> <b>::</b> Applicative f &#8658; (Type f, int, f a) &#8594; f [a]
			</li>
		
			</ul>
		</div>
	
		<div class="module-header">
			<div class="module-name">
			Module: <a href="#doc.module.Monadic.Async.AsyncComputation">Monadic.Async.AsyncComputation</a>
			</div>
			<ul class="module-functions">
				
			<li>
				<a href="#doc.module.Monadic.Async.AsyncComputation.func.new">
					<b>new</b>
				</a> <b>::</b> ((a &#8594; (), e &#8594; ()) &#8594; c) &#8594; Async c e a
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.AsyncComputation.func.fork">
					<b>fork</b>
				</a> <b>::</b> Async c e a &#8594; (a &#8594; (), e &#8594; ()) &#8594; ()
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.AsyncComputation.func.run">
					<b>run</b>
				</a> <b>::</b> Async c e a &#8594; ()
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.AsyncComputation.func.toPromise">
					<b>toPromise</b>
				</a> <b>::</b> Async c e a &#8594; Promise a e
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.AsyncComputation.func.bind">
					<b>bind</b>
				</a> <b>::</b> Async c e a &#8594; (a &#8594; Async c e b) &#8594; Async c e b
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.AsyncComputation.func.chain">
					<b>chain</b>
				</a> <b>::</b> Async c e a &#8594; (a &#8594; Async c e2 b) &#8594; Async c e2 b
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.AsyncComputation.func.chainFail">
					<b>chainFail</b>
				</a> <b>::</b> Async c e a &#8594; (e &#8594; Async c e2 b) &#8594; Async c e2 b
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.AsyncComputation.func.catch">
					<b>catch</b>
				</a> <b>::</b> Async c e a &#8594; (e &#8594; Async c e2 b) &#8594; Async c e2 b
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.AsyncComputation.func.map">
					<b>map</b>
				</a> <b>::</b> Async c e a &#8594; (a &#8594; b) &#8594; Async c e b
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.AsyncComputation.func.tap">
					<b>tap</b>
				</a> <b>::</b> Async c e a &#8594; (a &#8594; ()) &#8594; Async c e a
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.AsyncComputation.func.mapCatch">
					<b>mapCatch</b>
				</a> <b>::</b> Async c e a &#8594; (e &#8594; e2) &#8594; Async c e2 a
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.AsyncComputation.func.tapFail">
					<b>tapFail</b>
				</a> <b>::</b> Async c e a &#8594; (e &#8594; ()) &#8594; Async c e a
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.AsyncComputation.func.app">
					<b>app</b>
				</a> <b>::</b> Async c e (a &#8594; b) &#8594; Async c e a &#8594; Async c e b
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.AsyncComputation.func.ap">
					<b>ap</b>
				</a> <b>::</b> Async c e a &#8594; Async c e (a &#8594; b) &#8594; Async c e b
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.AsyncComputation.func.seqL">
					<b>seqL</b>
				</a> <b>::</b> Async c e a &#8594; Async c e b &#8594; Async c e a
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.AsyncComputation.func.seqR">
					<b>seqR</b>
				</a> <b>::</b> Async c e a &#8594; Async c e b &#8594; Async c e b
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.AsyncComputation.func.alt">
					<b>alt</b>
				</a> <b>::</b> Async c e a &#8594; Async c e b &#8594; Async c e (a | b)
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.AsyncComputation.func.doCase">
					<b>doCase</b>
				</a> <b>::</b> Async c e a &#8594; (((a &#8594; (), e &#8594; ()) &#8594; c) &#8594; b) &#8594; b
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.AsyncComputation.func.later">
					<b>later</b>
				</a> <b>::</b> (a &#8594; b) &#8594; a &#8594; ()
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.AsyncComputation.func.mapIt">
					<b>mapIt</b>
				</a> <b>::</b> ((b &#8594; ()), (e &#8594; ()), (a &#8594; b)) &#8594; (a &#8594; ())
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.AsyncComputation.func.chainIt">
					<b>chainIt</b>
				</a> <b>::</b> ((b &#8594; ()), (e &#8594; ()), (a &#8594; Async () e a)) &#8594; (a &#8594; ())
			</li>
		
			</ul>
		</div>
	
		<div class="module-header">
			<div class="module-name">
			Module: <a href="#doc.module.Monadic.Async.AsyncFirst">Monadic.Async.AsyncFirst</a>
			</div>
			<ul class="module-functions">
				
			<li>
				<a href="#doc.module.Monadic.Async.AsyncFirst.func.new">
					<b>new</b>
				</a> <b>::</b> [Async c e a] &#8594; Async c e a
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.AsyncFirst.func.fork">
					<b>fork</b>
				</a> <b>::</b> AsyncFirst e a &#8594; (a &#8594; b, e &#8594; c) &#8594; b | c
			</li>
		
			</ul>
		</div>
	
		<div class="module-header">
			<div class="module-name">
			Module: <a href="#doc.module.Monadic.Async">Monadic.Async</a>
			</div>
			<ul class="module-functions">
				
			<li>
				<a href="#doc.module.Monadic.Async.func.create">
					<b>create</b>
				</a> <b>::</b> ((a &#8594; ()) &#8594; (e &#8594; ()) &#8594; c) &#8594; Async c e a
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.func.try">
					<b>try</b>
				</a> <b>::</b> Async c e a &#8594; Async c e a
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.func.wrap">
					<b>wrap</b>
				</a> <b>::</b> ((...any, e &#8594; a &#8594; ()) &#8594; c) &#8594; ...any &#8594; Async c e a
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.func.wrapPromise">
					<b>wrapPromise</b>
				</a> <b>::</b> (...any &#8594; Promise a e) &#8594; ...any &#8594; Async (Promise a e) e a
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.func.unit">
					<b>unit</b>
				</a> <b>::</b> a &#8594; Async () () a
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.func.of">
					<b>of</b>
				</a> <b>::</b> a &#8594; Async () () a
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.func.fail">
					<b>fail</b>
				</a> <b>::</b> e &#8594; Async () e ()
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.func.run">
					<b>run</b>
				</a> <b>::</b> Async c e a &#8594; ()
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.func.fork">
					<b>fork</b>
				</a> <b>::</b> (Async c b a, (a &#8594; d), (b &#8594; e)) &#8594; c
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.func.toPromise">
					<b>toPromise</b>
				</a> <b>::</b> Async c e a &#8594; Promise a e
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.func.sleep">
					<b>sleep</b>
				</a> <b>::</b> int &#8594; Async int () ()
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.func.all">
					<b>all</b>
				</a> <b>::</b> ...Async c e a &#8594; Async c e [a]
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.func.first">
					<b>first</b>
				</a> <b>::</b> ...Async c e a &#8594; Async c e a
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.func.throwE">
					<b>throwE</b>
				</a> <b>::</b> e &#8594; Async () e ()
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.func.await">
					<b>await</b>
				</a> <b>::</b> Promise a e &#8594; Async (Promise a e) e a
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.func.fromPromise">
					<b>fromPromise</b>
				</a> <b>::</b> Promise a e &#8594; Async (Promise a e) e a
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.func.fromEither">
					<b>fromEither</b>
				</a> <b>::</b> Either e a &#8594; Async () e a
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.func.fromMaybe">
					<b>fromMaybe</b>
				</a> <b>::</b> Maybe a &#8594; Async () NonExistenceError a
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.func.parallel">
					<b>parallel</b>
				</a> <b>::</b> WebWorker &#8594; ((a_0..a_n) &#8594; b) &#8594; (a_0..a_n) &#8594; Async () Error b
			</li>
		
			</ul>
		</div>
	
		<div class="module-header">
			<div class="module-name">
			Module: <a href="#doc.module.Monadic.Async.AsyncHandler">Monadic.Async.AsyncHandler</a>
			</div>
			<ul class="module-functions">
				
			<li>
				<a href="#doc.module.Monadic.Async.AsyncHandler.func.">
					<b></b>
				</a> <b>::</b> onadic.Async.AsyncFirst
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.AsyncHandler.func.">
					<b></b>
				</a> <b>::</b> onadic.Async.AsyncComputation
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.AsyncHandler.func.prepare">
					<b>prepare</b>
				</a> <b>::</b> Interpreter &#8594; () &#8594; Async ()
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.AsyncHandler.func.map">
					<b>map</b>
				</a> <b>::</b> Interpreter &#8594; AsyncFunctor b a &#8594; [Async b a, (a &#8594; Free f a | Free f a)]
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.AsyncHandler.func.cleanup">
					<b>cleanup</b>
				</a> <b>::</b> Interpreter &#8594; a &#8594; Async () ()
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Async.AsyncHandler.func.cleanupErr">
					<b>cleanupErr</b>
				</a> <b>::</b> Interpreter &#8594; b &#8594; Async () ()
			</li>
		
			</ul>
		</div>
	
		<div class="module-header">
			<div class="module-name">
			Module: <a href="#doc.module.MonadicJS.Do.Analyze">MonadicJS.Do.Analyze</a>
			</div>
			<ul class="module-functions">
				
			<li>
				<a href="#doc.module.MonadicJS.Do.Analyze.func.analyze">
					<b>analyze</b>
				</a> <b>::</b> AST &#8594; AST
			</li>
		
			</ul>
		</div>
	
		<div class="module-header">
			<div class="module-name">
			Module: <a href="#doc.module.MonadicJS.Do.Generate">MonadicJS.Do.Generate</a>
			</div>
			<ul class="module-functions">
				
			<li>
				<a href="#doc.module.MonadicJS.Do.Generate.func.generate">
					<b>generate</b>
				</a> <b>::</b> AST &#8594; string
			</li>
		
			</ul>
		</div>
	
		<div class="module-header">
			<div class="module-name">
			Module: <a href="#doc.module.MonadicJS.do">MonadicJS.do</a>
			</div>
			<ul class="module-functions">
				
			<li>
				<a href="#doc.module.MonadicJS.do.func.loadDo">
					<b>loadDo</b>
				</a> <b>::</b> (string, bool) &#8594; ()
			</li>
		
			</ul>
		</div>
	
		<div class="module-header">
			<div class="module-name">
			Module: <a href="#doc.module.MonadicJS.do.Lexer">MonadicJS.do.Lexer</a>
			</div>
			<ul class="module-functions">
				
			</ul>
		</div>
	
		<div class="module-header">
			<div class="module-name">
			Module: <a href="#doc.module.MonadicJS.do.LexicalGrammar">MonadicJS.do.LexicalGrammar</a>
			</div>
			<ul class="module-functions">
				
			</ul>
		</div>
	
		<div class="module-header">
			<div class="module-name">
			Module: <a href="#doc.module.MonadicJS.Do.ParseDo">MonadicJS.Do.ParseDo</a>
			</div>
			<ul class="module-functions">
				
			<li>
				<a href="#doc.module.MonadicJS.Do.ParseDo.func.operators">
					<b>operators</b>
				</a> <b>::</b> Map string (Parser Token any) &#8594; Parser Token string
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Do.ParseDo.func.topLevel">
					<b>topLevel</b>
				</a> <b>::</b> (a, Parser Token AST) &#8594; Parser Token BinaryExpression
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Do.ParseDo.func.prefix">
					<b>prefix</b>
				</a> <b>::</b> (Parser Token string, Parser Token AST) &#8594; Parser Token AST
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Do.ParseDo.func.postfix">
					<b>postfix</b>
				</a> <b>::</b> (Parser Token string, Parser Token AST) &#8594; Parser Token AST
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Do.ParseDo.func.infixRight">
					<b>infixRight</b>
				</a> <b>::</b> (Parser Token string, Parser Token AST) &#8594; Parser Token AST
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Do.ParseDo.func.infixLeft">
					<b>infixLeft</b>
				</a> <b>::</b> (Parser Token string, Parser Token AST) &#8594; Parser Token AST
			</li>
		
			</ul>
		</div>
	
		<div class="module-header">
			<div class="module-name">
			Module: <a href="#doc.module.MonadicJS.Do.Transform">MonadicJS.Do.Transform</a>
			</div>
			<ul class="module-functions">
				
			<li>
				<a href="#doc.module.MonadicJS.Do.Transform.func.transform">
					<b>transform</b>
				</a> <b>::</b> (AST, string, AST) &#8594; AST
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Do.Transform.func.transformDoBlock">
					<b>transformDoBlock</b>
				</a> <b>::</b> (string, [AST]) &#8594; AST
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Do.Transform.func.transformUnaryExpr">
					<b>transformUnaryExpr</b>
				</a> <b>::</b> string &#8594; (string, AST) &#8594; AST
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Do.Transform.func.transformBinaryExpr">
					<b>transformBinaryExpr</b>
				</a> <b>::</b> string &#8594; (string, AST, AST) &#8594; AST
			</li>
		
			</ul>
		</div>
	
		<div class="module-header">
			<div class="module-name">
			Module: <a href="#doc.module.MonadicJS.Do.TransformJS">MonadicJS.Do.TransformJS</a>
			</div>
			<ul class="module-functions">
				
			<li>
				<a href="#doc.module.MonadicJS.Do.TransformJS.func.isDo">
					<b>isDo</b>
				</a> <b>::</b> [Token] &#8594; int &#8594; bool
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Do.TransformJS.func.transformJS">
					<b>transformJS</b>
				</a> <b>::</b> string &#8594; Either string string
			</li>
		
			</ul>
		</div>
	
		<div class="module-header">
			<div class="module-name">
			Module: <a href="#doc.module.Monadic.Either">Monadic.Either</a>
			</div>
			<ul class="module-functions">
				
			<li>
				<a href="#doc.module.Monadic.Either.func.unit/of">
					<b>unit/of</b>
				</a> <b>::</b> a &#8594; Right a
			</li>
		
			</ul>
		</div>
	
		<div class="module-header">
			<div class="module-name">
			Module: <a href="#doc.module.Monadic.Either.Left">Monadic.Either.Left</a>
			</div>
			<ul class="module-functions">
				
			<li>
				<a href="#doc.module.Monadic.Either.Left.func.new">
					<b>new</b>
				</a> <b>::</b> a &#8594; Left a
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Either.Left.func.map">
					<b>map</b>
				</a> <b>::</b> Left c &#8594; (a &#8594; b) &#8594; Left c
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Either.Left.func.bind">
					<b>bind</b>
				</a> <b>::</b> Left c &#8594; (a &#8594; Either c b) &#8594; Left c
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Either.Left.func.chain">
					<b>chain</b>
				</a> <b>::</b> Left c &#8594; (a &#8594; Either c b) &#8594; Left c
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Either.Left.func.doCase">
					<b>doCase</b>
				</a> <b>::</b> Left a &#8594; (a &#8594; b) &#8594; b
			</li>
		
			</ul>
		</div>
	
		<div class="module-header">
			<div class="module-name">
			Module: <a href="#doc.module.Monadic.Either.Right">Monadic.Either.Right</a>
			</div>
			<ul class="module-functions">
				
			<li>
				<a href="#doc.module.Monadic.Either.Right.func.new">
					<b>new</b>
				</a> <b>::</b> a &#8594; Right a
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Either.Right.func.map">
					<b>map</b>
				</a> <b>::</b> Right a &#8594; (a &#8594; b) &#8594; Right b
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Either.Right.func.bind">
					<b>bind</b>
				</a> <b>::</b> Right a &#8594; (a &#8594; Either c b) &#8594; Either c b
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Either.Right.func.chain">
					<b>chain</b>
				</a> <b>::</b> Right a &#8594; (a &#8594; Either c b) &#8594; Either c b
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Either.Right.func.doCase">
					<b>doCase</b>
				</a> <b>::</b> Right a &#8594; (a &#8594; b) &#8594; b
			</li>
		
			</ul>
		</div>
	
		<div class="module-header">
			<div class="module-name">
			Module: <a href="#doc.module.Monadic.Free.Free">Monadic.Free.Free</a>
			</div>
			<ul class="module-functions">
				
			<li>
				<a href="#doc.module.Monadic.Free.Free.func.new">
					<b>new</b>
				</a> <b>::</b> f (Free f a) &#8594; Free f a
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Free.Free.func.map">
					<b>map</b>
				</a> <b>::</b> Free f a &#8594; (a &#8594; b) &#8594; Free f b
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Free.Free.func.bind">
					<b>bind</b>
				</a> <b>::</b> Free f a &#8594; (a &#8594; Free f b) &#8594; Free f b
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Free.Free.func.chain">
					<b>chain</b>
				</a> <b>::</b> Free f a &#8594; (a &#8594; Free f b) &#8594; Free f b
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Free.Free.func.doCase">
					<b>doCase</b>
				</a> <b>::</b> Free f a &#8594; (f (Free f a) &#8594; b) &#8594; b
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Free.Free.func.ap">
					<b>ap</b>
				</a> <b>::</b> Free f (a &#8594; b) &#8594; Free f a &#8594; Free f b
			</li>
		
			</ul>
		</div>
	
		<div class="module-header">
			<div class="module-name">
			Module: <a href="#doc.module.Monadic.Free">Monadic.Free</a>
			</div>
			<ul class="module-functions">
				
			<li>
				<a href="#doc.module.Monadic.Free.func.unit/of">
					<b>unit/of</b>
				</a> <b>::</b> a &#8594; Free f a
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Free.func.liftF">
					<b>liftF</b>
				</a> <b>::</b> f a &#8594; Free f a
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Free.func.createInterpreter">
					<b>createInterpreter</b>
				</a> <b>::</b> Functor[f_0|f_n] &#8658; MonadFail m &#8594; [Interpreter[m, f_0|f_n]] &#8594; Free [f_0|f_n] a &#8594; m a
			</li>
		
			</ul>
		</div>
	
		<div class="module-header">
			<div class="module-name">
			Module: <a href="#doc.module.Monadic.Free.Return">Monadic.Free.Return</a>
			</div>
			<ul class="module-functions">
				
			<li>
				<a href="#doc.module.Monadic.Free.Return.func.new">
					<b>new</b>
				</a> <b>::</b> a &#8594; Free f a
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Free.Return.func.map">
					<b>map</b>
				</a> <b>::</b> Free f a &#8594; (a &#8594; b) &#8594; Free f b
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Free.Return.func.bind">
					<b>bind</b>
				</a> <b>::</b> Free f a &#8594; (a &#8594; Free f b) &#8594; Free f b
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Free.Return.func.chain">
					<b>chain</b>
				</a> <b>::</b> Free f a &#8594; (a &#8594; Free f b) &#8594; Free f b
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Free.Return.func.doCase">
					<b>doCase</b>
				</a> <b>::</b> Free f a &#8594; (a &#8594; b) &#8594; b
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Free.Return.func.ap">
					<b>ap</b>
				</a> <b>::</b> Free f (a &#8594; b) &#8594; Free f a &#8594; Free f b
			</li>
		
			</ul>
		</div>
	
		<div class="module-header">
			<div class="module-name">
			Module: <a href="#doc.module.Monadic.Maybe">Monadic.Maybe</a>
			</div>
			<ul class="module-functions">
				
			<li>
				<a href="#doc.module.Monadic.Maybe.func.unit/of">
					<b>unit/of</b>
				</a> <b>::</b> a &#8594; Just a
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Maybe.func.nullable">
					<b>nullable</b>
				</a> <b>::</b> a &#8594; Maybe a
			</li>
		
			</ul>
		</div>
	
		<div class="module-header">
			<div class="module-name">
			Module: <a href="#doc.module.Monadic.Maybe.Just">Monadic.Maybe.Just</a>
			</div>
			<ul class="module-functions">
				
			<li>
				<a href="#doc.module.Monadic.Maybe.Just.func.new">
					<b>new</b>
				</a> <b>::</b> a &#8594; Just a
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Maybe.Just.func.map">
					<b>map</b>
				</a> <b>::</b> Just a &#8594; (a &#8594; b) &#8594; Just b
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Maybe.Just.func.bind">
					<b>bind</b>
				</a> <b>::</b> Just a &#8594; (a &#8594; Maybe b) &#8594; Maybe b
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Maybe.Just.func.chain">
					<b>chain</b>
				</a> <b>::</b> Just a &#8594; (a &#8594; Maybe b) &#8594; Maybe b
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Maybe.Just.func.doCase">
					<b>doCase</b>
				</a> <b>::</b> Just a &#8594; (a &#8594; b) &#8594; b
			</li>
		
			</ul>
		</div>
	
		<div class="module-header">
			<div class="module-name">
			Module: <a href="#doc.module.Monadic.Maybe.Nothing">Monadic.Maybe.Nothing</a>
			</div>
			<ul class="module-functions">
				
			<li>
				<a href="#doc.module.Monadic.Maybe.Nothing.func.map">
					<b>map</b>
				</a> <b>::</b> Nothing &#8594; (a &#8594; b) &#8594; Nothing
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Maybe.Nothing.func.bind">
					<b>bind</b>
				</a> <b>::</b> Nothing &#8594; (a &#8594; Maybe b) &#8594; Nothing
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Maybe.Nothing.func.chain">
					<b>chain</b>
				</a> <b>::</b> Nothing &#8594; (a &#8594; Maybe b) &#8594; Nothing
			</li>
		
			<li>
				<a href="#doc.module.Monadic.Maybe.Nothing.func.doCase">
					<b>doCase</b>
				</a> <b>::</b> Nothing &#8594; (() &#8594; b) &#8594; b
			</li>
		
			</ul>
		</div>
	
		<div class="module-header">
			<div class="module-name">
			Module: <a href="#doc.module.MonadicJS.Parser">MonadicJS.Parser</a>
			</div>
			<ul class="module-functions">
				
			<li>
				<a href="#doc.module.MonadicJS.Parser.func.runParser">
					<b>runParser</b>
				</a> <b>::</b> (Parser t a, bool?) &#8594; ([t], int?) &#8594; Either ParseError (ParseResult a)
			</li>
		
			</ul>
		</div>
	
		<div class="module-header">
			<div class="module-name">
			Module: <a href="#doc.module.MonadicJS.Parser.Parser">MonadicJS.Parser.Parser</a>
			</div>
			<ul class="module-functions">
				
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.new">
					<b>new</b>
				</a> <b>::</b> ([t] &#8594; int &#8594; LeftRecContext &#8594; State ParseState (Either ParserError (ParseResult a))) &#8594; Parser t a
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.app">
					<b>app</b>
				</a> <b>::</b> Parser t (a &#8594; b) &#8594; Parser t a &#8594; Parser t b
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.ap">
					<b>ap</b>
				</a> <b>::</b> Parser t a &#8594; Parser t (a &#8594; b) &#8594; Parser t b
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.seqR">
					<b>seqR</b>
				</a> <b>::</b> Parser t a &#8594; Parser t b &#8594; Parser t b
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.seqL">
					<b>seqL</b>
				</a> <b>::</b> Parser t a &#8594; Parser t b &#8594; Parser t a
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.then">
					<b>then</b>
				</a> <b>::</b> Parser t a &#8594; Parser t b &#8594; Parser t b
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.skip">
					<b>skip</b>
				</a> <b>::</b> Parser t a &#8594; Parser t b &#8594; Parser t a
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.alt">
					<b>alt</b>
				</a> <b>::</b> Parser t a &#8594; Parser t b &#8594; Parser t (a | b)
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.or">
					<b>or</b>
				</a> <b>::</b> Parser t a &#8594; Parser t b &#8594; Parser t (a | b)
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.wrap">
					<b>wrap</b>
				</a> <b>::</b> Parser t a &#8594; Parser t b &#8594; Parser t c &#8594; Parser t a
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.trim">
					<b>trim</b>
				</a> <b>::</b> Parser t a &#8594; Parser t b &#8594; Parser t a
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.some">
					<b>some</b>
				</a> <b>::</b> Parser t a &#8594; Parser t [a]
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.sepByPlus">
					<b>sepByPlus</b>
				</a> <b>::</b> Parser t a &#8594; Parser t b &#8594; Parser t [a]
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.many">
					<b>many</b>
				</a> <b>::</b> Parser t a &#8594; Parser t [a]
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.sepBy">
					<b>sepBy</b>
				</a> <b>::</b> Parser t a &#8594; Parser t b &#8594; Parser t [a]
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.map">
					<b>map</b>
				</a> <b>::</b> Parser t a &#8594; (a &#8594; b) &#8594; Parser t b
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.result">
					<b>result</b>
				</a> <b>::</b> Parser t a &#8594; b &#8594; Parser t b
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.fallback">
					<b>fallback</b>
				</a> <b>::</b> Parser t a &#8594; b &#8594; Parser t (a | b)
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.bind">
					<b>bind</b>
				</a> <b>::</b> Parser t a &#8594; (a &#8594; Parser t b) &#8594; Parser t b
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.chain">
					<b>chain</b>
				</a> <b>::</b> Parser t a &#8594; (a &#8594; Parser t b) &#8594; Parser t b
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.memoize">
					<b>memoize</b>
				</a> <b>::</b> Parser t a &#8594; bool? &#8594; any? &#8594; Parser t a
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.runParser">
					<b>runParser</b>
				</a> <b>::</b> Parser t a &#8594; [t] &#8594; int &#8594; LeftRecContext &#8594; State ParseState (Either ParseError (ParseResult a))
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.Parser">
					<b>Parser</b>
				</a> <b>::</b> ([t] &#8594; int &#8594; LeftRecContext &#8594; State ParseState (Either ParserError (ParseResult a))) &#8594; Parser t a
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.of/unit">
					<b>of/unit</b>
				</a> <b>::</b> a &#8594; Parser t a
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.empty">
					<b>empty</b>
				</a> <b>::</b> Parser t ()
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.zero">
					<b>zero</b>
				</a> <b>::</b> () &#8594; Parser t ()
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.getlrec">
					<b>getlrec</b>
				</a> <b>::</b> LefRecContext &#8594; int &#8594; int &#8594; LeftRecContext
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.mergeUps">
					<b>mergeUps</b>
				</a> <b>::</b> int &#8594; int &#8594; Set a &#8594; Set a &#8594; Set a
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.pruneContext">
					<b>pruneContext</b>
				</a> <b>::</b> Set (Parser t any) &#8594; Map (Parser t any) int &#8594; Map (Parser t any) int
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.lookup">
					<b>lookup</b>
				</a> <b>::</b> Parser t a &#8594; int &#8594; LeftRecContext &#8594; Map (Parser t a) (Map int (Either ParseError [(ParseResult a), LeftRecContext])) &#8594; ParseResult a | null
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.canReuse">
					<b>canReuse</b>
				</a> <b>::</b> LeftRecContext &#8594; LeftRecContext &#8594; bool
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.cons">
					<b>cons</b>
				</a> <b>::</b> a &#8594; [a] &#8594; [a]
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.ParseResult">
					<b>ParseResult</b>
				</a> <b>::</b> int &#8594; a &#8594; ParseResult a
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.Succeed">
					<b>Succeed</b>
				</a> <b>::</b> int &#8594; a &#8594; Either ParseError (ParseResult a)
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.ParseError">
					<b>ParseError</b>
				</a> <b>::</b> int &#8594; Error &#8594; ParseError
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.Fail">
					<b>Fail</b>
				</a> <b>::</b> int &#8594; Error &#8594; ParseError
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.stringTerm">
					<b>stringTerm</b>
				</a> <b>::</b> string &#8594; Parser string string
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.regexTerm">
					<b>regexTerm</b>
				</a> <b>::</b> RegExp &#8594; string &#8594; Parser string [string]
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.tokenTerm">
					<b>tokenTerm</b>
				</a> <b>::</b> (t &#8594; bool) &#8594; Parser t t
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.recursive">
					<b>recursive</b>
				</a> <b>::</b> (() &#8594; Parser t a) &#8594; Parser t a
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.findToken">
					<b>findToken</b>
				</a> <b>::</b> (t &#8594; bool) &#8594; string &#8594; Parser t t
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.lookahead">
					<b>lookahead</b>
				</a> <b>::</b> Parser t a &#8594; Parser t bool
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.any">
					<b>any</b>
				</a> <b>::</b> Parser t t
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.all">
					<b>all</b>
				</a> <b>::</b> Parser t [t]
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.eof">
					<b>eof</b>
				</a> <b>::</b> Parser t ()
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.fail">
					<b>fail</b>
				</a> <b>::</b> Error &#8594; Parser t ()
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.Parser.Parser.func.showError">
					<b>showError</b>
				</a> <b>::</b> ParseError &#8594; ([t], int) &#8594; string
			</li>
		
			</ul>
		</div>
	
		<div class="module-header">
			<div class="module-name">
			Module: <a href="#doc.module.MonadicJS.State">MonadicJS.State</a>
			</div>
			<ul class="module-functions">
				
			<li>
				<a href="#doc.module.MonadicJS.State.func.new">
					<b>new</b>
				</a> <b>::</b> (s &#8594; [t, s]) &#8594; State s t
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.State.func.runState">
					<b>runState</b>
				</a> <b>::</b> State s t &#8594; s &#8594; [t, s]
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.State.func.bind">
					<b>bind</b>
				</a> <b>::</b> State s a &#8594; (a &#8594; State s b) &#8594; State s b
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.State.func.map">
					<b>map</b>
				</a> <b>::</b> State s a &#8594; (a &#8594; b) &#8594; State s b
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.State.func.chain">
					<b>chain</b>
				</a> <b>::</b> State s a &#8594; (a &#8594; State s b) &#8594; State s b
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.State.func.State">
					<b>State</b>
				</a> <b>::</b> (s &#8594; [a, s]) &#8594; State s a
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.State.func.unit/of">
					<b>unit/of</b>
				</a> <b>::</b> a &#8594; State s a
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.State.func.get">
					<b>get</b>
				</a> <b>::</b> State s s
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.State.func.put">
					<b>put</b>
				</a> <b>::</b> s &#8594; State s ()
			</li>
		
			<li>
				<a href="#doc.module.MonadicJS.State.func.modify">
					<b>modify</b>
				</a> <b>::</b> (s &#8594; s) &#8594; State s ()
			</li>
		
			</ul>
		</div>
	
			</div>
			<div class="project-description">
			<h2>Module Description</h2>
			
		<div class="module-description" id="doc.module.MonadicJS.ArrayExtensions">
			<div class="module-name">
				Module: MonadicJS.ArrayExtensions
			</div>
			<div class="module-author">
			<b>Written By:</b> 
			</div>
			<div class="module-date">
			<b>Written On:</b> 
			</div>
			<div class="module-desc">
			WARNING: This modifies the Array prototype
so you should always unload it when done. You
may still mess other code up if you use these
extensions in an asynchronous section of code.
			</div>
			<div class="module-functions">
				
			</div>
		</div>
	
		<div class="module-description" id="doc.module.MonadicJS.FunctionExtensions">
			<div class="module-name">
				Module: MonadicJS.FunctionExtensions
			</div>
			<div class="module-author">
			<b>Written By:</b> 
			</div>
			<div class="module-date">
			<b>Written On:</b> 
			</div>
			<div class="module-desc">
			WARNING: This modifies the Function prototype
so you should always unload it when done. You
may still mess other code up if you use these
extensions in an asynchronous section of code.<br><br>NOTE: Using the do-notation/expr language extension
will automatically load these extensions. That is because
they include kleisi composition, which it provides an operator
for.
			</div>
			<div class="module-functions">
				
			<div class="function-description"
			id="doc.module.MonadicJS.FunctionExtensions.func.map">
				<div class="function-name">
					<b>map</b> <b>::</b> (a &#8594; b) &#8594; (b &#8594; c) &#8594; a &#8594; c
				</div>
				<div class="function-desc">
					
Sequencing of functions.<br><br>The Haskell definition is composition of functions
but we define map with its arguments backwards for
all our Functors so it can live on the object, which
means out map = flip haskellmap = sequence
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.FunctionExtensions.func.chain">
				<div class="function-name">
					<b>chain</b> <b>::</b> (a &#8594; b) &#8594; (b &#8594; (a &#8594; c)) &#8594; a &#8594; c
				</div>
				<div class="function-desc">
					
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.FunctionExtensions.func.arrow">
				<div class="function-name">
					<b>arrow</b> <b>::</b> Monad m &#8658; (a &#8594; m b) &#8594; (b &#8594; m c) &#8594; a &#8594; m c
				</div>
				<div class="function-desc">
					
Left-to-right Kleisi composition of monadic functions.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.FunctionExtensions.func.alt">
				<div class="function-name">
					<b>alt</b> <b>::</b> Alternative f &#8658; (a &#8594; f b) &#8594; (a &#8594; f c) &#8594; a &#8594; f (b | c)
				</div>
				<div class="function-desc">
					
This lifts the alternative combinator for an Alternative to
work on alternative returning functions. Note that this will
always evaluate both functions to use the alternative instance
of their return values. As long as your alternative is side-effect
free, this won't cause any problems. If it is not and those side-effects
are critical (ie, not console.logs or something similar), you might
wind up with corrupt data somewhere.
				</div>
			</div>
		
			</div>
		</div>
	
		<div class="module-description" id="doc.module.Monadic">
			<div class="module-name">
				Module: Monadic
			</div>
			<div class="module-author">
			<b>Written By:</b> Joel Dentici
			</div>
			<div class="module-date">
			<b>Written On:</b> 6/20/2017
			</div>
			<div class="module-desc">
			This library provides implementations of common
monads in JavaScript.<br><br>Utility functions for working with monads abstractly are also
provided, as well as a generator-based do-notation utility.
			</div>
			<div class="module-functions">
				
			</div>
		</div>
	
		<div class="module-description" id="doc.module.Monadic.Utility">
			<div class="module-name">
				Module: Monadic.Utility
			</div>
			<div class="module-author">
			<b>Written By:</b> Joel Dentici
			</div>
			<div class="module-date">
			<b>Written On:</b> 6/20/2017
			</div>
			<div class="module-desc">
			Utility functions for working with monads, applicatives,
alternatives, and just functional stuff in general.
			</div>
			<div class="module-functions">
				
			<div class="function-description"
			id="doc.module.Monadic.Utility.func.doM">
				<div class="function-name">
					<b>doM</b> <b>::</b> Monad m &#8658; (() &#8594; Iterator) &#8594; m a
				</div>
				<div class="function-desc">
					
Do notation helper for monads. Taken from:
https://curiosity-driven.org/monads-in-javascript<br><br>Example Usage:
<pre>
const result = doM(function() {
const fst = yield Either.right(5);
const snd = yield Either.right(11);
return Either.unit(fst + snd);
});
</pre><br><br>Note: It is recommended that you use the
do-notation language extension provided,
instead of this. Using this weird generator
fu can lead to problems since generators cannot
be reused, but a do-notation block is supposed
to be a value semantically, which means it should
be able to be reused. The generator approach also
cannot accommodate monads like the list monad that
apply their bound function more than once.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Utility.func.when">
				<div class="function-name">
					<b>when</b> <b>::</b> Applicative f &#8658; (bool, f ()) &#8594; f ()
				</div>
				<div class="function-desc">
					
Performs the specified action when the specified
condition is true.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Utility.func.unless">
				<div class="function-name">
					<b>unless</b> <b>::</b> Applicative f &#8658; (bool, f ()) &#8594; f ()
				</div>
				<div class="function-desc">
					
Performs the specified action when the specified
condition is false.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Utility.func.guard">
				<div class="function-name">
					<b>guard</b> <b>::</b> Alternative f &#8658; (bool, Type f) &#8594; f ()
				</div>
				<div class="function-desc">
					
Guards further MonadPlus binding/sequencing when
the provided condition is false, due to the law
that empty >>= f = empty
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Utility.func.constant">
				<div class="function-name">
					<b>constant</b> <b>::</b> a &#8594; () &#8594; a
				</div>
				<div class="function-desc">
					
When applied to a value, returns a function
that will always return that value, regardless
of what it is applied to.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Utility.func.id">
				<div class="function-name">
					<b>id</b> <b>::</b> a &#8594; a
				</div>
				<div class="function-desc">
					
Always returns the value it is applied to.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Utility.func.foldrM">
				<div class="function-name">
					<b>foldrM</b> <b>::</b> Foldable t, Monad m &#8658; (Type m, (a, b) &#8594; m b) &#8594; b &#8594; t a &#8594; m b
				</div>
				<div class="function-desc">
					
Monadic fold over a structure, from right to left.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Utility.func.foldlM">
				<div class="function-name">
					<b>foldlM</b> <b>::</b> Foldable t, Monad m &#8658; (Type m, (b, a) &#8594; m b) &#8594; b &#8594; t a &#8594; m b
				</div>
				<div class="function-desc">
					
Monadic fold over a structure, from left to right.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Utility.func.filterM">
				<div class="function-name">
					<b>filterM</b> <b>::</b> Consable t, Applicative f &#8658; (Type f, (a &#8594; f bool)) &#8594; t a &#8594; f (t a)
				</div>
				<div class="function-desc">
					
Filters a specified list by using a predicate with results
in the specified applicative. Returns the filtered list in the
specified applicative.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Utility.func.mapM">
				<div class="function-name">
					<b>mapM</b> <b>::</b> Consable t, Applicative f &#8658; (Type f, (a &#8594; f b)) &#8594; t a &#8594; f (t b)
				</div>
				<div class="function-desc">
					
mapM defined to work over any Consable structure and with Applicatives.<br><br>TODO: Implement the more generic Traversables and traverse and
define this in terms of that
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Utility.func.all">
				<div class="function-name">
					<b>all</b> <b>::</b> Applicative f &#8658; (Type f, [f a]) &#8594; f [a]
				</div>
				<div class="function-desc">
					
Collects the results of a list of applicative
actions into a list. This is more efficient than
mapM (Type f, id), because it uses array push on
the result list rather than creating intermediate arrays.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Utility.func.replicateM">
				<div class="function-name">
					<b>replicateM</b> <b>::</b> Applicative f &#8658; (Type f, int, f a) &#8594; f [a]
				</div>
				<div class="function-desc">
					
Repeats the specified action cnt times and collects
the results into a list.
				</div>
			</div>
		
			</div>
		</div>
	
		<div class="module-description" id="doc.module.Monadic.Async.AsyncComputation">
			<div class="module-name">
				Module: Monadic.Async.AsyncComputation
			</div>
			<div class="module-author">
			<b>Written By:</b> Joel Dentici
			</div>
			<div class="module-date">
			<b>Written On:</b> 6/25/2017
			</div>
			<div class="module-desc">
			Holds a thunked computation.
			</div>
			<div class="module-functions">
				
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncComputation.func.new">
				<div class="function-name">
					<b>new</b> <b>::</b> ((a &#8594; (), e &#8594; ()) &#8594; c) &#8594; Async c e a
				</div>
				<div class="function-desc">
					
Creates an Async computation from the provided thunked
computation, which will be called with callbacks for a result
or error when the Async computation is forked/ran.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncComputation.func.fork">
				<div class="function-name">
					<b>fork</b> <b>::</b> Async c e a &#8594; (a &#8594; (), e &#8594; ()) &#8594; ()
				</div>
				<div class="function-desc">
					
Runs the Async computation. The success or fail
function is applied to its result, depending on
whether it is successful or not.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncComputation.func.run">
				<div class="function-name">
					<b>run</b> <b>::</b> Async c e a &#8594; ()
				</div>
				<div class="function-desc">
					
Forks the computation and throws away the results.<br><br>Useful for when you were using the Async results to
do side effects that could throw errors in a tap
and wanted to catch them using chainFail/catch.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncComputation.func.toPromise">
				<div class="function-name">
					<b>toPromise</b> <b>::</b> Async c e a &#8594; Promise a e
				</div>
				<div class="function-desc">
					
This is the same as forking the computation, but
you get back a Promise for the result.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncComputation.func.bind">
				<div class="function-name">
					<b>bind</b> <b>::</b> Async c e a &#8594; (a &#8594; Async c e b) &#8594; Async c e b
				</div>
				<div class="function-desc">
					
Alias for chain.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncComputation.func.chain">
				<div class="function-name">
					<b>chain</b> <b>::</b> Async c e a &#8594; (a &#8594; Async c e2 b) &#8594; Async c e2 b
				</div>
				<div class="function-desc">
					
Monadic binding of Async computations. The computations
run sequentially. Failed computations do not get piped
through.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncComputation.func.chainFail">
				<div class="function-name">
					<b>chainFail</b> <b>::</b> Async c e a &#8594; (e &#8594; Async c e2 b) &#8594; Async c e2 b
				</div>
				<div class="function-desc">
					
Same as chain/bind but the function is applied when this
computation fails.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncComputation.func.catch">
				<div class="function-name">
					<b>catch</b> <b>::</b> Async c e a &#8594; (e &#8594; Async c e2 b) &#8594; Async c e2 b
				</div>
				<div class="function-desc">
					
Alias for chainFail.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncComputation.func.map">
				<div class="function-name">
					<b>map</b> <b>::</b> Async c e a &#8594; (a &#8594; b) &#8594; Async c e b
				</div>
				<div class="function-desc">
					
Applies the function to the result of this computation.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncComputation.func.tap">
				<div class="function-name">
					<b>tap</b> <b>::</b> Async c e a &#8594; (a &#8594; ()) &#8594; Async c e a
				</div>
				<div class="function-desc">
					
Tap into the Async computation at a certain point
to perform a side effect. This should be used with
care and mainly only by the consumer of an Async computation.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncComputation.func.mapCatch">
				<div class="function-name">
					<b>mapCatch</b> <b>::</b> Async c e a &#8594; (e &#8594; e2) &#8594; Async c e2 a
				</div>
				<div class="function-desc">
					
Applies the function to the error of this computation.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncComputation.func.tapFail">
				<div class="function-name">
					<b>tapFail</b> <b>::</b> Async c e a &#8594; (e &#8594; ()) &#8594; Async c e a
				</div>
				<div class="function-desc">
					
Tap for failures.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncComputation.func.app">
				<div class="function-name">
					<b>app</b> <b>::</b> Async c e (a &#8594; b) &#8594; Async c e a &#8594; Async c e b
				</div>
				<div class="function-desc">
					
Applicative application. Applies the function result of
this Async computation to the result of the specified Async
computation. If used with an n-ary curried function, then
app can be chained n times to fully apply it.<br><br>This is written such that chained applications will run
the computations concurrently.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncComputation.func.ap">
				<div class="function-name">
					<b>ap</b> <b>::</b> Async c e a &#8594; Async c e (a &#8594; b) &#8594; Async c e b
				</div>
				<div class="function-desc">
					
Flipped arguments for app. This is for fantasy-land, but
probably isn't very useful as it breaks chaining.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncComputation.func.seqL">
				<div class="function-name">
					<b>seqL</b> <b>::</b> Async c e a &#8594; Async c e b &#8594; Async c e a
				</div>
				<div class="function-desc">
					
Sequences Async computations, keeping the value of
the one on the left. The computations are ran concurrently.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncComputation.func.seqR">
				<div class="function-name">
					<b>seqR</b> <b>::</b> Async c e a &#8594; Async c e b &#8594; Async c e b
				</div>
				<div class="function-desc">
					
Sequence Async computations, keeping the value of
the one on the right. The computations are ran concurrently.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncComputation.func.alt">
				<div class="function-name">
					<b>alt</b> <b>::</b> Async c e a &#8594; Async c e b &#8594; Async c e (a | b)
				</div>
				<div class="function-desc">
					
Alternative sequencing. The computation on the left is
ran and if it is successful, its result is used. If it
fails, then the computation on the right is ran and its
result is used.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncComputation.func.doCase">
				<div class="function-name">
					<b>doCase</b> <b>::</b> Async c e a &#8594; (((a &#8594; (), e &#8594; ()) &#8594; c) &#8594; b) &#8594; b
				</div>
				<div class="function-desc">
					
Applies the function to the thunked computation.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncComputation.func.later">
				<div class="function-name">
					<b>later</b> <b>::</b> (a &#8594; b) &#8594; a &#8594; ()
				</div>
				<div class="function-desc">
					
Wraps the application to the specified function
in an application of the immediate function.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncComputation.func.mapIt">
				<div class="function-name">
					<b>mapIt</b> <b>::</b> ((b &#8594; ()), (e &#8594; ()), (a &#8594; b)) &#8594; (a &#8594; ())
				</div>
				<div class="function-desc">
					
Returns a new function that applies fn to whatever value
it gets and then applies cont to that. If an error occurs
in fn, then we will catch it and fail with it.<br><br>Note: This allows breaking out of the monadic control flow
by throwing in a map, but it is very important that we don't
bring down an entire application by one Async computation having
an error in it.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncComputation.func.chainIt">
				<div class="function-name">
					<b>chainIt</b> <b>::</b> ((b &#8594; ()), (e &#8594; ()), (a &#8594; Async () e a)) &#8594; (a &#8594; ())
				</div>
				<div class="function-desc">
					
Performs the monadic chaining while catching any errors that occur.
				</div>
			</div>
		
			</div>
		</div>
	
		<div class="module-description" id="doc.module.Monadic.Async.AsyncFirst">
			<div class="module-name">
				Module: Monadic.Async.AsyncFirst
			</div>
			<div class="module-author">
			<b>Written By:</b> Joel Dentici
			</div>
			<div class="module-date">
			<b>Written On:</b> 6/25/2017
			</div>
			<div class="module-desc">
			Holds a set of AsyncComputations.
			</div>
			<div class="module-functions">
				
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncFirst.func.new">
				<div class="function-name">
					<b>new</b> <b>::</b> [Async c e a] &#8594; Async c e a
				</div>
				<div class="function-desc">
					
Constructs an AsyncFirst
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncFirst.func.fork">
				<div class="function-name">
					<b>fork</b> <b>::</b> AsyncFirst e a &#8594; (a &#8594; b, e &#8594; c) &#8594; b | c
				</div>
				<div class="function-desc">
					
This overrides the AsyncComputation fork to fork all
the Async computations and keep the result of whatever
finishes first.
				</div>
			</div>
		
			</div>
		</div>
	
		<div class="module-description" id="doc.module.Monadic.Async">
			<div class="module-name">
				Module: Monadic.Async
			</div>
			<div class="module-author">
			<b>Written By:</b> Joel Dentici
			</div>
			<div class="module-date">
			<b>Written On:</b> 6/25/2017
			</div>
			<div class="module-desc">
			The Async monad represents computations
that run in an asynchronous context.<br><br>Unlike Promises, an Async computation is
lazily evaluated, so it won't be executed
immediately. Asyncs can be turned into Promises
by calling "run" on them and Promises can be turned
into Asyncs by applying Async.fromPromise to them
			</div>
			<div class="module-functions">
				
			<div class="function-description"
			id="doc.module.Monadic.Async.func.create">
				<div class="function-name">
					<b>create</b> <b>::</b> ((a &#8594; ()) &#8594; (e &#8594; ()) &#8594; c) &#8594; Async c e a
				</div>
				<div class="function-desc">
					
Creates an Async computation. Takes a function that
accepts two functions, one for a successful computation
an one for a failed computation. This function is not
executed until the Async is ran.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.func.try">
				<div class="function-name">
					<b>try</b> <b>::</b> Async c e a &#8594; Async c e a
				</div>
				<div class="function-desc">
					
This method literally doesn't do anything. It is just
here to make catching look more imperative by surrounding
it with try.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.func.wrap">
				<div class="function-name">
					<b>wrap</b> <b>::</b> ((...any, e &#8594; a &#8594; ()) &#8594; c) &#8594; ...any &#8594; Async c e a
				</div>
				<div class="function-desc">
					
Wraps a callback taking async function so it becomes a function
that returns Async computations.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.func.wrapPromise">
				<div class="function-name">
					<b>wrapPromise</b> <b>::</b> (...any &#8594; Promise a e) &#8594; ...any &#8594; Async (Promise a e) e a
				</div>
				<div class="function-desc">
					
Wraps a promise returning async function so it becomes a function
that returns Async computations.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.func.unit">
				<div class="function-name">
					<b>unit</b> <b>::</b> a &#8594; Async () () a
				</div>
				<div class="function-desc">
					
Puts a value into the context of
an Async computation.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.func.of">
				<div class="function-name">
					<b>of</b> <b>::</b> a &#8594; Async () () a
				</div>
				<div class="function-desc">
					
Alias for unit. Provided for fantasy-land
compliance.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.func.fail">
				<div class="function-name">
					<b>fail</b> <b>::</b> e &#8594; Async () e ()
				</div>
				<div class="function-desc">
					
Returns an Async computation that failed
for the specified reason.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.func.run">
				<div class="function-name">
					<b>run</b> <b>::</b> Async c e a &#8594; ()
				</div>
				<div class="function-desc">
					
Runs the asynchronous computation, discarding
the result.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.func.fork">
				<div class="function-name">
					<b>fork</b> <b>::</b> (Async c b a, (a &#8594; d), (b &#8594; e)) &#8594; c
				</div>
				<div class="function-desc">
					
Runs the asynchronous computation. Its result
will be passed to succ or fail as appropriate.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.func.toPromise">
				<div class="function-name">
					<b>toPromise</b> <b>::</b> Async c e a &#8594; Promise a e
				</div>
				<div class="function-desc">
					
Forks the computation and returns a promise
for its result.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.func.sleep">
				<div class="function-name">
					<b>sleep</b> <b>::</b> int &#8594; Async int () ()
				</div>
				<div class="function-desc">
					
Creates an Async computation that sleeps for the specified
timespan in milliseconds and returns no result.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.func.all">
				<div class="function-name">
					<b>all</b> <b>::</b> ...Async c e a &#8594; Async c e [a]
				</div>
				<div class="function-desc">
					
Returns an Async computation whose result
combines all the results from the provided
Asyncs.<br><br>If any of the Asyncs fail, then the resulting
Async will have its error.<br><br>This can be called with an array or rest args.<br><br>There must be at least one computation provided,
regardless of how this is called.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.func.first">
				<div class="function-name">
					<b>first</b> <b>::</b> ...Async c e a &#8594; Async c e a
				</div>
				<div class="function-desc">
					
Returns an Async computation whose result is
the result of the first provided computation to
finish.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.func.throwE">
				<div class="function-name">
					<b>throwE</b> <b>::</b> e &#8594; Async () e ()
				</div>
				<div class="function-desc">
					
Alias of fail
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.func.await">
				<div class="function-name">
					<b>await</b> <b>::</b> Promise a e &#8594; Async (Promise a e) e a
				</div>
				<div class="function-desc">
					
This basically just maps Promises into
Asyncs.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.func.fromPromise">
				<div class="function-name">
					<b>fromPromise</b> <b>::</b> Promise a e &#8594; Async (Promise a e) e a
				</div>
				<div class="function-desc">
					
Alias of await
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.func.fromEither">
				<div class="function-name">
					<b>fromEither</b> <b>::</b> Either e a &#8594; Async () e a
				</div>
				<div class="function-desc">
					
Creates an Async computation whose result or failure
is the value in the specified Either.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.func.fromMaybe">
				<div class="function-name">
					<b>fromMaybe</b> <b>::</b> Maybe a &#8594; Async () NonExistenceError a
				</div>
				<div class="function-desc">
					
Creates an Async computation whose result is the
value in the Maybe. If the Maybe is Nothing, then
the Async computation will result in a NonExistenceError.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.func.parallel">
				<div class="function-name">
					<b>parallel</b> <b>::</b> WebWorker &#8594; ((a_0..a_n) &#8594; b) &#8594; (a_0..a_n) &#8594; Async () Error b
				</div>
				<div class="function-desc">
					
Allows running functions in a fully parallel context.<br><br>Functions cannot be curried! If you try to use a curried
function with this, the result will be a CurryingError.
If you pass in a function that has already been curried,
you will get a ReferenceError on its curried arguments.
This is because the function is serialized to source and
passed to the worker for execution. Serializing a curried
function does not carry its environment, so it will have
free variables in its body.<br><br>Applying parallel to a WebWorker implementation returns
a function that can be used to wrap functions to run
on another thread/process and return their results in
an Async.<br><br>Note that you can achieve concurrency with CPU-bound
computations by just using Async computations -- All
you need to do is break them up into chains where you
return results with Async.of or even just by chaining
map from an initial Async.of() and turn iteration into
recursion (you can also write most loops as higher order
functions but that is inelegant). This works, but it isn't
truly parallel as it doesn't utilize multiple CPU cores. It
is essentially just time-sharing of coroutines (which can be
faster than threads or processes for simple tasks).<br><br>Using this will give you truly parallel computation.
				</div>
			</div>
		
			</div>
		</div>
	
		<div class="module-description" id="doc.module.Monadic.Async.AsyncHandler">
			<div class="module-name">
				Module: Monadic.Async.AsyncHandler
			</div>
			<div class="module-author">
			<b>Written By:</b> Joel Dentici
			</div>
			<div class="module-date">
			<b>Written On:</b> 6/25/2017
			</div>
			<div class="module-desc">
			Holds an AsyncComputation and a handler
for a failed computation.
			</div>
			<div class="module-functions">
				
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncHandler.func.">
				<div class="function-name">
					<b></b> <b>::</b> onadic.Async.AsyncFirst
				</div>
				<div class="function-desc">
					written by Joel Dentici
on 6/25/2017<br><br>Holds a set of AsyncComputations.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncHandler.func.">
				<div class="function-name">
					<b></b> <b>::</b> onadic.Async.AsyncComputation
				</div>
				<div class="function-desc">
					written by Joel Dentici
on 6/25/2017<br><br>Holds a thunked computation.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncHandler.func.prepare">
				<div class="function-name">
					<b>prepare</b> <b>::</b> Interpreter &#8594; () &#8594; Async ()
				</div>
				<div class="function-desc">
					
Prepares interpretation context for Async.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncHandler.func.map">
				<div class="function-name">
					<b>map</b> <b>::</b> Interpreter &#8594; AsyncFunctor b a &#8594; [Async b a, (a &#8594; Free f a | Free f a)]
				</div>
				<div class="function-desc">
					
Maps an AsyncComputation into a new Async, essentially doing
nothing.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncHandler.func.cleanup">
				<div class="function-name">
					<b>cleanup</b> <b>::</b> Interpreter &#8594; a &#8594; Async () ()
				</div>
				<div class="function-desc">
					
We don't need to clean up anything.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Async.AsyncHandler.func.cleanupErr">
				<div class="function-name">
					<b>cleanupErr</b> <b>::</b> Interpreter &#8594; b &#8594; Async () ()
				</div>
				<div class="function-desc">
					
We don't need to clean up anything.
				</div>
			</div>
		
			</div>
		</div>
	
		<div class="module-description" id="doc.module.MonadicJS.Do.Analyze">
			<div class="module-name">
				Module: MonadicJS.Do.Analyze
			</div>
			<div class="module-author">
			<b>Written By:</b> Joel Dentici
			</div>
			<div class="module-date">
			<b>Written On:</b> 7/10/2017
			</div>
			<div class="module-desc">
			Performs analysis on do notation blocks
in an AST, looking for pieces that can be
optimized to use applicative, rather than
monadic, application and sequencing.<br><br>The resulting AST has nodes that can be used
in applicative style marked as such.
			</div>
			<div class="module-functions">
				
			<div class="function-description"
			id="doc.module.MonadicJS.Do.Analyze.func.analyze">
				<div class="function-name">
					<b>analyze</b> <b>::</b> AST &#8594; AST
				</div>
				<div class="function-desc">
					
Performs analysis on the provided AST.<br><br>TODO: Implement this.
				</div>
			</div>
		
			</div>
		</div>
	
		<div class="module-description" id="doc.module.MonadicJS.Do.Generate">
			<div class="module-name">
				Module: MonadicJS.Do.Generate
			</div>
			<div class="module-author">
			<b>Written By:</b> Joel Dentici
			</div>
			<div class="module-date">
			<b>Written On:</b> 7/10/2017
			</div>
			<div class="module-desc">
			Generates JavaScript output from a
Transformed AST.
			</div>
			<div class="module-functions">
				
			<div class="function-description"
			id="doc.module.MonadicJS.Do.Generate.func.generate">
				<div class="function-name">
					<b>generate</b> <b>::</b> AST &#8594; string
				</div>
				<div class="function-desc">
					
Maps the AST to a string by traversing it
and mapping each node that is encountered to a string.
				</div>
			</div>
		
			</div>
		</div>
	
		<div class="module-description" id="doc.module.MonadicJS.do">
			<div class="module-name">
				Module: MonadicJS.do
			</div>
			<div class="module-author">
			<b>Written By:</b> Joel Dentici
			</div>
			<div class="module-date">
			<b>Written On:</b> 6/30/2017
			</div>
			<div class="module-desc">
			Provides ability to use do notation without
relying on generators. This leads to fancier
code and the ability to use monads that apply
their bound function more than once, like list.<br><br>This module provides a function that can be called
to install a hook into the node module loader, which
will cause any later require() calls to have their
module's source processed through this module. The
transforming function itself is exported so you can
write a simple source-to-source compiler if you prefer that.
			</div>
			<div class="module-functions">
				
			<div class="function-description"
			id="doc.module.MonadicJS.do.func.loadDo">
				<div class="function-name">
					<b>loadDo</b> <b>::</b> (string, bool) &#8594; ()
				</div>
				<div class="function-desc">
					
Hooks into the node module loader and registers the
specified extension to be pre-compiled by the do-notation
transformer.<br><br>The default extension used when none is specified is '.ejs'<br><br>The second argument can be used to get verbose output from
this function:
Level 0 - Errors only
Level 1 - Level 0 + Loading messages & compilation time
Level 2 - Level 1 + Compilation output
				</div>
			</div>
		
			</div>
		</div>
	
		<div class="module-description" id="doc.module.MonadicJS.do.Lexer">
			<div class="module-name">
				Module: MonadicJS.do.Lexer
			</div>
			<div class="module-author">
			<b>Written By:</b> Joel Dentici
			</div>
			<div class="module-date">
			<b>Written On:</b> 7/1/2017
			</div>
			<div class="module-desc">
			This module performs lexical analysis on an
input string according to a provided lexical
grammar.
			</div>
			<div class="module-functions">
				
			</div>
		</div>
	
		<div class="module-description" id="doc.module.MonadicJS.do.LexicalGrammar">
			<div class="module-name">
				Module: MonadicJS.do.LexicalGrammar
			</div>
			<div class="module-author">
			<b>Written By:</b> Joel Dentici
			</div>
			<div class="module-date">
			<b>Written On:</b> 7/1/2017
			</div>
			<div class="module-desc">
			This module defines the lexical grammar (parts of
the CFG that can be recognized by regular expressions)
for a subset of JavaScript's lexical gramar.
			</div>
			<div class="module-functions">
				
			</div>
		</div>
	
		<div class="module-description" id="doc.module.MonadicJS.Do.ParseDo">
			<div class="module-name">
				Module: MonadicJS.Do.ParseDo
			</div>
			<div class="module-author">
			<b>Written By:</b> Joel Dentici
			</div>
			<div class="module-date">
			<b>Written On:</b> 7/10/2017
			</div>
			<div class="module-desc">
			This module defines the parser for
do notation and expression blocks.<br><br>This should be used in conjunction with
the lexer module and the provided lexical grammar.
			</div>
			<div class="module-functions">
				
			<div class="function-description"
			id="doc.module.MonadicJS.Do.ParseDo.func.operators">
				<div class="function-name">
					<b>operators</b> <b>::</b> Map string (Parser Token any) &#8594; Parser Token string
				</div>
				<div class="function-desc">
					
Creates a single parser from a map from operator
names to operator parsers. Each parser in the map
is made to yield its name as its result.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Do.ParseDo.func.topLevel">
				<div class="function-name">
					<b>topLevel</b> <b>::</b> (a, Parser Token AST) &#8594; Parser Token BinaryExpression
				</div>
				<div class="function-desc">
					
Creates a parser for the top level precedence operators
in JavaScript. These are the member access and function application
which both have weird syntax compared to other operators.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Do.ParseDo.func.prefix">
				<div class="function-name">
					<b>prefix</b> <b>::</b> (Parser Token string, Parser Token AST) &#8594; Parser Token AST
				</div>
				<div class="function-desc">
					
Creates a parser for a prefix operator(s).
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Do.ParseDo.func.postfix">
				<div class="function-name">
					<b>postfix</b> <b>::</b> (Parser Token string, Parser Token AST) &#8594; Parser Token AST
				</div>
				<div class="function-desc">
					
Creates a parser for a postfix operator(s).
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Do.ParseDo.func.infixRight">
				<div class="function-name">
					<b>infixRight</b> <b>::</b> (Parser Token string, Parser Token AST) &#8594; Parser Token AST
				</div>
				<div class="function-desc">
					
Creates a parser for an infix operator(s) that is
right associative.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Do.ParseDo.func.infixLeft">
				<div class="function-name">
					<b>infixLeft</b> <b>::</b> (Parser Token string, Parser Token AST) &#8594; Parser Token AST
				</div>
				<div class="function-desc">
					
Creates a parser for an infix operator(s) that is
left associative.
				</div>
			</div>
		
			</div>
		</div>
	
		<div class="module-description" id="doc.module.MonadicJS.Do.Transform">
			<div class="module-name">
				Module: MonadicJS.Do.Transform
			</div>
			<div class="module-author">
			<b>Written By:</b> Joel Dentici
			</div>
			<div class="module-date">
			<b>Written On:</b> 7/10/2017
			</div>
			<div class="module-desc">
			Provides a function to replace do-blocks,
if-blocks, and other specialized syntax (non-js 
operators) with valid js syntax.
			</div>
			<div class="module-functions">
				
			<div class="function-description"
			id="doc.module.MonadicJS.Do.Transform.func.transform">
				<div class="function-name">
					<b>transform</b> <b>::</b> (AST, string, AST) &#8594; AST
				</div>
				<div class="function-desc">
					
Transforms the AST in the manner described
above.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Do.Transform.func.transformDoBlock">
				<div class="function-name">
					<b>transformDoBlock</b> <b>::</b> (string, [AST]) &#8594; AST
				</div>
				<div class="function-desc">
					
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Do.Transform.func.transformUnaryExpr">
				<div class="function-name">
					<b>transformUnaryExpr</b> <b>::</b> string &#8594; (string, AST) &#8594; AST
				</div>
				<div class="function-desc">
					
Transforms return expressions to applications of
the current monad's "of" function. If we are not
in a do-block, then the return is left as is and
will become a statement in the output JS.<br><br>All other unary operator expressions are returned
unchanged.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Do.Transform.func.transformBinaryExpr">
				<div class="function-name">
					<b>transformBinaryExpr</b> <b>::</b> string &#8594; (string, AST, AST) &#8594; AST
				</div>
				<div class="function-desc">
					
Transforms the binary expression. If its operator is one
of those in exprOps, then we transform it to the appropriate
function application
				</div>
			</div>
		
			</div>
		</div>
	
		<div class="module-description" id="doc.module.MonadicJS.Do.TransformJS">
			<div class="module-name">
				Module: MonadicJS.Do.TransformJS
			</div>
			<div class="module-author">
			<b>Written By:</b> Joel Dentici
			</div>
			<div class="module-date">
			<b>Written On:</b> 7/10/2017
			</div>
			<div class="module-desc">
			This module provides a function to transform
JavaScript source that contains do and expr
blocks to an equivalent one with those blocks
mapped to actual JavaScript syntax.<br><br>This relies on lexing the source, scanning until
a block is found, emitting tokens that are not
part of a block immediately to the output buffer.<br><br>Once a block is found, we begin parsing at the current
input position. The AST of the parsed block is then
analyzed and transformed to get a new AST with only
JavaScript syntax. That AST is finally mapped back to 
JavaScript source code by the generator.<br><br>After a block has been fully transformed, we begin
scanning and immediate re-emitting until we find another
block.<br><br>The resulting output buffers are concatenated and returned.
			</div>
			<div class="module-functions">
				
			<div class="function-description"
			id="doc.module.MonadicJS.Do.TransformJS.func.isDo">
				<div class="function-name">
					<b>isDo</b> <b>::</b> [Token] &#8594; int &#8594; bool
				</div>
				<div class="function-desc">
					
Checks if we are at a possible do block.<br><br>We check for a "do" followed by an identifier
skipping any whitespace and comments. This is
to ensure that we don't accidentally consider
a do-while loop to be a do-notation block.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Do.TransformJS.func.transformJS">
				<div class="function-name">
					<b>transformJS</b> <b>::</b> string &#8594; Either string string
				</div>
				<div class="function-desc">
					
Transforms the input source code in the manner
described above.<br><br>If an error occurs while parsing a do-block or
expr block, then it will be returned after being
formatted into a readable string. Otherwise,
the resulting source code is returned. The first
error to occur will stop any further transformation.
				</div>
			</div>
		
			</div>
		</div>
	
		<div class="module-description" id="doc.module.Monadic.Either">
			<div class="module-name">
				Module: Monadic.Either
			</div>
			<div class="module-author">
			<b>Written By:</b> Joel Dentici
			</div>
			<div class="module-date">
			<b>Written On:</b> 6/20/2017
			</div>
			<div class="module-desc">
			Defines the Either monad.
			</div>
			<div class="module-functions">
				
			<div class="function-description"
			id="doc.module.Monadic.Either.func.unit/of">
				<div class="function-name">
					<b>unit/of</b> <b>::</b> a &#8594; Right a
				</div>
				<div class="function-desc">
					
Puts a value into Either context.
				</div>
			</div>
		
			</div>
		</div>
	
		<div class="module-description" id="doc.module.Monadic.Either.Left">
			<div class="module-name">
				Module: Monadic.Either.Left
			</div>
			<div class="module-author">
			<b>Written By:</b> Joel Dentici
			</div>
			<div class="module-date">
			<b>Written On:</b> 6/20/2017
			</div>
			<div class="module-desc">
			The Left constructor
			</div>
			<div class="module-functions">
				
			<div class="function-description"
			id="doc.module.Monadic.Either.Left.func.new">
				<div class="function-name">
					<b>new</b> <b>::</b> a &#8594; Left a
				</div>
				<div class="function-desc">
					
Construct a Left
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Either.Left.func.map">
				<div class="function-name">
					<b>map</b> <b>::</b> Left c &#8594; (a &#8594; b) &#8594; Left c
				</div>
				<div class="function-desc">
					
Doesn't apply the function per Either semantics.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Either.Left.func.bind">
				<div class="function-name">
					<b>bind</b> <b>::</b> Left c &#8594; (a &#8594; Either c b) &#8594; Left c
				</div>
				<div class="function-desc">
					
Doesn't apply the function per Either semantics.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Either.Left.func.chain">
				<div class="function-name">
					<b>chain</b> <b>::</b> Left c &#8594; (a &#8594; Either c b) &#8594; Left c
				</div>
				<div class="function-desc">
					
Alias for bind. Provided for fantasy-land compliance.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Either.Left.func.doCase">
				<div class="function-name">
					<b>doCase</b> <b>::</b> Left a &#8594; (a &#8594; b) &#8594; b
				</div>
				<div class="function-desc">
					
Applies the function to the value in the
Left
				</div>
			</div>
		
			</div>
		</div>
	
		<div class="module-description" id="doc.module.Monadic.Either.Right">
			<div class="module-name">
				Module: Monadic.Either.Right
			</div>
			<div class="module-author">
			<b>Written By:</b> Joel Dentici
			</div>
			<div class="module-date">
			<b>Written On:</b> 6/20/2017
			</div>
			<div class="module-desc">
			The Right constructor
			</div>
			<div class="module-functions">
				
			<div class="function-description"
			id="doc.module.Monadic.Either.Right.func.new">
				<div class="function-name">
					<b>new</b> <b>::</b> a &#8594; Right a
				</div>
				<div class="function-desc">
					
Construct a Right
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Either.Right.func.map">
				<div class="function-name">
					<b>map</b> <b>::</b> Right a &#8594; (a &#8594; b) &#8594; Right b
				</div>
				<div class="function-desc">
					
Apply the function to the value contained
in this Right.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Either.Right.func.bind">
				<div class="function-name">
					<b>bind</b> <b>::</b> Right a &#8594; (a &#8594; Either c b) &#8594; Either c b
				</div>
				<div class="function-desc">
					
Apply the function to the value contained
in this Right.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Either.Right.func.chain">
				<div class="function-name">
					<b>chain</b> <b>::</b> Right a &#8594; (a &#8594; Either c b) &#8594; Either c b
				</div>
				<div class="function-desc">
					
Alias for bind. Provided for fantasy-land compliance.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Either.Right.func.doCase">
				<div class="function-name">
					<b>doCase</b> <b>::</b> Right a &#8594; (a &#8594; b) &#8594; b
				</div>
				<div class="function-desc">
					
Apply the function to the value contained
in this Right.
				</div>
			</div>
		
			</div>
		</div>
	
		<div class="module-description" id="doc.module.Monadic.Free.Free">
			<div class="module-name">
				Module: Monadic.Free.Free
			</div>
			<div class="module-author">
			<b>Written By:</b> Joel Dentici
			</div>
			<div class="module-date">
			<b>Written On:</b> 6/20/2017
			</div>
			<div class="module-desc">
			Implementation of the free monad.
			</div>
			<div class="module-functions">
				
			<div class="function-description"
			id="doc.module.Monadic.Free.Free.func.new">
				<div class="function-name">
					<b>new</b> <b>::</b> f (Free f a) &#8594; Free f a
				</div>
				<div class="function-desc">
					
Takes a value in the functor over the free monad over that
functor and places it into the context of the free monad
over that functor. In other words, this nests the free monad
context one level, which will later be stripped away in an interpreter.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Free.Free.func.map">
				<div class="function-name">
					<b>map</b> <b>::</b> Free f a &#8594; (a &#8594; b) &#8594; Free f b
				</div>
				<div class="function-desc">
					
Apply the function within the free monad context.<br><br>This means we map the function recursively by mapping
it on the free monad context contained in the functor
contained in this free monad. Eventually we will hit a
Return and the recursion will stop.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Free.Free.func.bind">
				<div class="function-name">
					<b>bind</b> <b>::</b> Free f a &#8594; (a &#8594; Free f b) &#8594; Free f b
				</div>
				<div class="function-desc">
					
Apply the function within the free monad context.<br><br>This means we bind the function to the free monad
inside the functor in this free monad (which is
recursive). Eventually we will hit a Return and the
recursion will stop.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Free.Free.func.chain">
				<div class="function-name">
					<b>chain</b> <b>::</b> Free f a &#8594; (a &#8594; Free f b) &#8594; Free f b
				</div>
				<div class="function-desc">
					
Alias for bind. Provided for fantasy-land compliance.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Free.Free.func.doCase">
				<div class="function-name">
					<b>doCase</b> <b>::</b> Free f a &#8594; (f (Free f a) &#8594; b) &#8594; b
				</div>
				<div class="function-desc">
					
Apply the function to the functor in this context.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Free.Free.func.ap">
				<div class="function-name">
					<b>ap</b> <b>::</b> Free f (a &#8594; b) &#8594; Free f a &#8594; Free f b
				</div>
				<div class="function-desc">
					
Applies the function in this Free to the value
inside the provided Free.
				</div>
			</div>
		
			</div>
		</div>
	
		<div class="module-description" id="doc.module.Monadic.Free">
			<div class="module-name">
				Module: Monadic.Free
			</div>
			<div class="module-author">
			<b>Written By:</b> Joel Dentici
			</div>
			<div class="module-date">
			<b>Written On:</b> 6/20/2017
			</div>
			<div class="module-desc">
			Defines the Free monad over a Functor.<br><br>data Free f a = Free (f (Free f a)) | Return a
			</div>
			<div class="module-functions">
				
			<div class="function-description"
			id="doc.module.Monadic.Free.func.unit/of">
				<div class="function-name">
					<b>unit/of</b> <b>::</b> a &#8594; Free f a
				</div>
				<div class="function-desc">
					
Puts a value into the Free monad over
a functor.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Free.func.liftF">
				<div class="function-name">
					<b>liftF</b> <b>::</b> f a &#8594; Free f a
				</div>
				<div class="function-desc">
					
Lifts a value in the functor into the Free
monad over that functor.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Free.func.createInterpreter">
				<div class="function-name">
					<b>createInterpreter</b> <b>::</b> Functor[f_0|f_n] &#8658; MonadFail m &#8594; [Interpreter[m, f_0|f_n]] &#8594; Free [f_0|f_n] a &#8594; m a
				</div>
				<div class="function-desc">
					
Creates an interpreter that can interpret a "composite" of Free
monads.<br><br>A monad with an additional "fail" operation is supplied.<br><br>An Interpreter constructor is supplied for each type of Free
monad that this new interpreter will work for.
				</div>
			</div>
		
			</div>
		</div>
	
		<div class="module-description" id="doc.module.Monadic.Free.Return">
			<div class="module-name">
				Module: Monadic.Free.Return
			</div>
			<div class="module-author">
			<b>Written By:</b> Joel Dentici
			</div>
			<div class="module-date">
			<b>Written On:</b> 6/20/2017
			</div>
			<div class="module-desc">
			The "leaves" of the Free functor nesting
mess are contained in Return values.
			</div>
			<div class="module-functions">
				
			<div class="function-description"
			id="doc.module.Monadic.Free.Return.func.new">
				<div class="function-name">
					<b>new</b> <b>::</b> a &#8594; Free f a
				</div>
				<div class="function-desc">
					
Takes a value of type a and wraps it
into the free monad.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Free.Return.func.map">
				<div class="function-name">
					<b>map</b> <b>::</b> Free f a &#8594; (a &#8594; b) &#8594; Free f b
				</div>
				<div class="function-desc">
					
Apply the function to the value contained
in this container.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Free.Return.func.bind">
				<div class="function-name">
					<b>bind</b> <b>::</b> Free f a &#8594; (a &#8594; Free f b) &#8594; Free f b
				</div>
				<div class="function-desc">
					
Apply the function to the value contained in this
container
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Free.Return.func.chain">
				<div class="function-name">
					<b>chain</b> <b>::</b> Free f a &#8594; (a &#8594; Free f b) &#8594; Free f b
				</div>
				<div class="function-desc">
					
Alias for bind. Provided for fantasy-land compliance.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Free.Return.func.doCase">
				<div class="function-name">
					<b>doCase</b> <b>::</b> Free f a &#8594; (a &#8594; b) &#8594; b
				</div>
				<div class="function-desc">
					
Apply the function to the value contained
in this context.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Free.Return.func.ap">
				<div class="function-name">
					<b>ap</b> <b>::</b> Free f (a &#8594; b) &#8594; Free f a &#8594; Free f b
				</div>
				<div class="function-desc">
					
Applies the function in this Return to the
value in the provided Free.
				</div>
			</div>
		
			</div>
		</div>
	
		<div class="module-description" id="doc.module.Monadic.Maybe">
			<div class="module-name">
				Module: Monadic.Maybe
			</div>
			<div class="module-author">
			<b>Written By:</b> Joel Dentici
			</div>
			<div class="module-date">
			<b>Written On:</b> 6/20/2017
			</div>
			<div class="module-desc">
			Defines the Maybe monad.
			</div>
			<div class="module-functions">
				
			<div class="function-description"
			id="doc.module.Monadic.Maybe.func.unit/of">
				<div class="function-name">
					<b>unit/of</b> <b>::</b> a &#8594; Just a
				</div>
				<div class="function-desc">
					
Puts a value into Maybe context.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Maybe.func.nullable">
				<div class="function-name">
					<b>nullable</b> <b>::</b> a &#8594; Maybe a
				</div>
				<div class="function-desc">
					
Puts a value into Maybe context. If it
is null or undefined, Nothing is returned.
				</div>
			</div>
		
			</div>
		</div>
	
		<div class="module-description" id="doc.module.Monadic.Maybe.Just">
			<div class="module-name">
				Module: Monadic.Maybe.Just
			</div>
			<div class="module-author">
			<b>Written By:</b> Joel Dentici
			</div>
			<div class="module-date">
			<b>Written On:</b> 6/20/2017
			</div>
			<div class="module-desc">
			The Just constructor
			</div>
			<div class="module-functions">
				
			<div class="function-description"
			id="doc.module.Monadic.Maybe.Just.func.new">
				<div class="function-name">
					<b>new</b> <b>::</b> a &#8594; Just a
				</div>
				<div class="function-desc">
					
Construct a Just
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Maybe.Just.func.map">
				<div class="function-name">
					<b>map</b> <b>::</b> Just a &#8594; (a &#8594; b) &#8594; Just b
				</div>
				<div class="function-desc">
					
Apply the function to the value contained
in this Just.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Maybe.Just.func.bind">
				<div class="function-name">
					<b>bind</b> <b>::</b> Just a &#8594; (a &#8594; Maybe b) &#8594; Maybe b
				</div>
				<div class="function-desc">
					
Apply the function to the value contained
in this Just.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Maybe.Just.func.chain">
				<div class="function-name">
					<b>chain</b> <b>::</b> Just a &#8594; (a &#8594; Maybe b) &#8594; Maybe b
				</div>
				<div class="function-desc">
					
Alias for bind. Provided for fantasy-land compliance.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Maybe.Just.func.doCase">
				<div class="function-name">
					<b>doCase</b> <b>::</b> Just a &#8594; (a &#8594; b) &#8594; b
				</div>
				<div class="function-desc">
					
Apply the function to the value contained
in this Just.
				</div>
			</div>
		
			</div>
		</div>
	
		<div class="module-description" id="doc.module.Monadic.Maybe.Nothing">
			<div class="module-name">
				Module: Monadic.Maybe.Nothing
			</div>
			<div class="module-author">
			<b>Written By:</b> Joel Dentici
			</div>
			<div class="module-date">
			<b>Written On:</b> 6/20/2017
			</div>
			<div class="module-desc">
			The Nothing type
			</div>
			<div class="module-functions">
				
			<div class="function-description"
			id="doc.module.Monadic.Maybe.Nothing.func.map">
				<div class="function-name">
					<b>map</b> <b>::</b> Nothing &#8594; (a &#8594; b) &#8594; Nothing
				</div>
				<div class="function-desc">
					
Doesn't apply the function per Maybe semantics.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Maybe.Nothing.func.bind">
				<div class="function-name">
					<b>bind</b> <b>::</b> Nothing &#8594; (a &#8594; Maybe b) &#8594; Nothing
				</div>
				<div class="function-desc">
					
Doesn't apply the function per Maybe semantics.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Maybe.Nothing.func.chain">
				<div class="function-name">
					<b>chain</b> <b>::</b> Nothing &#8594; (a &#8594; Maybe b) &#8594; Nothing
				</div>
				<div class="function-desc">
					
Alias for bind. Provided for fantasy-land compliance.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.Monadic.Maybe.Nothing.func.doCase">
				<div class="function-name">
					<b>doCase</b> <b>::</b> Nothing &#8594; (() &#8594; b) &#8594; b
				</div>
				<div class="function-desc">
					
Applies the function
				</div>
			</div>
		
			</div>
		</div>
	
		<div class="module-description" id="doc.module.MonadicJS.Parser">
			<div class="module-name">
				Module: MonadicJS.Parser
			</div>
			<div class="module-author">
			<b>Written By:</b> Joel Dentici
			</div>
			<div class="module-date">
			<b>Written On:</b> 7/3/2017
			</div>
			<div class="module-desc">
			Applicative Parser combinators for JavaScript.<br><br>The parsers are LL() and uses a modified version of the parsing algorithm
given by Frost, Hafiz, and Callaghan to handle left recursion
and provide memoization of parse results. This is an LL parser, unlike the
parser they give so it only returns the left-most parse (derivation) according
to the grammar it is parsing.<br><br>These parsers do not require a separate lexical analysis step, but their
performance can be improved by using one. The combinators can be used to perfrom
this lexical analysis step, but it will probably be more efficient to write
a procedure specific to this.<br><br>It implements the following Fantasyland algebras:
	Functor
	Apply
	Applicative
	Alt
	Plus
	Alternative
	Chain
	Monad<br><br>We also alias our names for the operations of the
above algebras, as well as providing aliases for
names specific to parsing.<br><br>The names for some operations were taken from Parsimmon.
			</div>
			<div class="module-functions">
				
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.func.runParser">
				<div class="function-name">
					<b>runParser</b> <b>::</b> (Parser t a, bool?) &#8594; ([t], int?) &#8594; Either ParseError (ParseResult a)
				</div>
				<div class="function-desc">
					
Runs the provided parser on the provided input. Either
a ParseError or ParseResult a is returned depending on
whether the parser failed or succeeded. Both contain the position
in the input last parsed. ParseError additionally contains an
Error and ParseResult contains a value of type a.
				</div>
			</div>
		
			</div>
		</div>
	
		<div class="module-description" id="doc.module.MonadicJS.Parser.Parser">
			<div class="module-name">
				Module: MonadicJS.Parser.Parser
			</div>
			<div class="module-author">
			<b>Written By:</b> Joel Dentici
			</div>
			<div class="module-date">
			<b>Written On:</b> 7/5/2017
			</div>
			<div class="module-desc">
			Parser type. Implements applicative,
alternative, functor, and monad algebras.<br><br>Parsers automatically detect and fail
left recursion infinite descent of a parser, so that
other parsers can be tried.<br><br>Parsers can be memoized. This
increases parsing efficiency for grammars
where backtracking is necessary (ie ambiguous grammars).
			</div>
			<div class="module-functions">
				
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.new">
				<div class="function-name">
					<b>new</b> <b>::</b> ([t] &#8594; int &#8594; LeftRecContext &#8594; State ParseState (Either ParserError (ParseResult a))) &#8594; Parser t a
				</div>
				<div class="function-desc">
					
Constructs a parser from the provided function.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.app">
				<div class="function-name">
					<b>app</b> <b>::</b> Parser t (a &#8594; b) &#8594; Parser t a &#8594; Parser t b
				</div>
				<div class="function-desc">
					
Applicative Functor application<br><br>Returns a parser that:<br><br>Applies a function in parser context to the
result of a parser. If the function is curried
and has more arguments, then ap can be changed.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.ap">
				<div class="function-name">
					<b>ap</b> <b>::</b> Parser t a &#8594; Parser t (a &#8594; b) &#8594; Parser t b
				</div>
				<div class="function-desc">
					
Applicative functor application, conforming to the
fantasy-land spec.<br><br>Unfortunately, the fantasy-land spec has the parameters
backwards from the Haskell function, which makes applicative
application unnatural. Use app for a more natural applicative
interface.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.seqR">
				<div class="function-name">
					<b>seqR</b> <b>::</b> Parser t a &#8594; Parser t b &#8594; Parser t b
				</div>
				<div class="function-desc">
					
Applicative Functor sequential application<br><br>Returns a parser that:<br><br>First applies this parser, then the provided
parser, dropping the result of this parser.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.seqL">
				<div class="function-name">
					<b>seqL</b> <b>::</b> Parser t a &#8594; Parser t b &#8594; Parser t a
				</div>
				<div class="function-desc">
					
Applicative Functor sequential application<br><br>Returns a parser that:<br><br>First applies this parser, then the provided
parser, dropping the result of the provided parser.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.then">
				<div class="function-name">
					<b>then</b> <b>::</b> Parser t a &#8594; Parser t b &#8594; Parser t b
				</div>
				<div class="function-desc">
					
Alias for seqR. Provided as the name is more
meaningful in the domain of parsing.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.skip">
				<div class="function-name">
					<b>skip</b> <b>::</b> Parser t a &#8594; Parser t b &#8594; Parser t a
				</div>
				<div class="function-desc">
					
Alias for seqL. Provided as the name is more
meaningful in the domain of parsing.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.alt">
				<div class="function-name">
					<b>alt</b> <b>::</b> Parser t a &#8594; Parser t b &#8594; Parser t (a | b)
				</div>
				<div class="function-desc">
					
Alternative Applicative Functor choice application<br><br>Returns a parser that:<br><br>Applies this parser first. If it fails, then
the provided parser is applied. The result of
the last applied parser is returned.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.or">
				<div class="function-name">
					<b>or</b> <b>::</b> Parser t a &#8594; Parser t b &#8594; Parser t (a | b)
				</div>
				<div class="function-desc">
					
Alias for alt. Provided as the name is more meaningful
in the domain of parsing.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.wrap">
				<div class="function-name">
					<b>wrap</b> <b>::</b> Parser t a &#8594; Parser t b &#8594; Parser t c &#8594; Parser t a
				</div>
				<div class="function-desc">
					
Returns a parser that applies (prev, this, next) in sequence,
keeping the results of this.<br><br>Equivalent to prev.seqR(this).seqL(next)
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.trim">
				<div class="function-name">
					<b>trim</b> <b>::</b> Parser t a &#8594; Parser t b &#8594; Parser t a
				</div>
				<div class="function-desc">
					
Returns a parser that applies (around, this, around) in sequence,
keeping the results of this.<br><br>Equivalent to this.wrap(around, around) or around.seqR(this).seqL(around).
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.some">
				<div class="function-name">
					<b>some</b> <b>::</b> Parser t a &#8594; Parser t [a]
				</div>
				<div class="function-desc">
					
Alternative Applicative Functor some<br><br>Returns a parser that:<br><br>Applies this parser at least once to
get a list of the results that this parser
returns.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.sepByPlus">
				<div class="function-name">
					<b>sepByPlus</b> <b>::</b> Parser t a &#8594; Parser t b &#8594; Parser t [a]
				</div>
				<div class="function-desc">
					
Same as sepBy, but expects this parser to match
at least once. Essentially the same as the distinction
between some and many.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.many">
				<div class="function-name">
					<b>many</b> <b>::</b> Parser t a &#8594; Parser t [a]
				</div>
				<div class="function-desc">
					
Alternative Applicative Functor many<br><br>Returns a parser that:<br><br>Applies this parser zero or more times
to get a list of the results that this
parser returns.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.sepBy">
				<div class="function-name">
					<b>sepBy</b> <b>::</b> Parser t a &#8594; Parser t b &#8594; Parser t [a]
				</div>
				<div class="function-desc">
					
Returns a parser that tries to repeat applications
of this parser, separated by applications of the
provided parser.<br><br>This is equivalent to looking for this parser
followed by the provided parser or the empty parser
an [0, infinity) (many) number of times.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.map">
				<div class="function-name">
					<b>map</b> <b>::</b> Parser t a &#8594; (a &#8594; b) &#8594; Parser t b
				</div>
				<div class="function-desc">
					
Functor map<br><br>Returns a parser that:<br><br>Applies this parser to the input. If it succeeds,
the provided function is applied to its result
and the result of that application is returned.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.result">
				<div class="function-name">
					<b>result</b> <b>::</b> Parser t a &#8594; b &#8594; Parser t b
				</div>
				<div class="function-desc">
					
Returns a parser that runs this parser first,
but always maps its result to the provided value.<br><br>Useful with stringTerm parsers that only recognize
a single value, but you may want a static, semantically
meaningful result.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.fallback">
				<div class="function-name">
					<b>fallback</b> <b>::</b> Parser t a &#8594; b &#8594; Parser t (a | b)
				</div>
				<div class="function-desc">
					
Returns a parser that first tries this parser,
but always returns the provided value when this
parser fails.<br><br>Equivalent to this.alt(Parser.of(value))
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.bind">
				<div class="function-name">
					<b>bind</b> <b>::</b> Parser t a &#8594; (a &#8594; Parser t b) &#8594; Parser t b
				</div>
				<div class="function-desc">
					
Monadic bind<br><br>Returns a parser that:<br><br>First applies this parser to get a result. If
successful, the provided function is applied
to the result to get a new parser. That parser
is then applied to get the result.<br><br>You should use the applicative interface
in cases where you don't need to make context-sensitive
decisions. Obviously if context is required to parse,
the monadic interface must be used as it is the only
combinator that allows decisions to be made at runtime.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.chain">
				<div class="function-name">
					<b>chain</b> <b>::</b> Parser t a &#8594; (a &#8594; Parser t b) &#8594; Parser t b
				</div>
				<div class="function-desc">
					
Alias for bind. Provided for fantasy-land compliance.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.memoize">
				<div class="function-name">
					<b>memoize</b> <b>::</b> Parser t a &#8594; bool? &#8594; any? &#8594; Parser t a
				</div>
				<div class="function-desc">
					
Returns an equivalent parser that memoizes
results, up to curtailment of left recursion.<br><br>This should generally be applied to non-terminals.
Applying it too liberally can actually cause worse
performance.<br><br>The optional boolean argument tells memoize whether
the original parser is even or odd (based on how
many parsers it chains together, only at the top
level). This is used to give the correct left-most
parse when left-recursion occurs because it lets us
avoid an off-by-one error when we attribute curtailment
too deep by assuming an even parity.<br><br>The optional name argument allows you to provide the
value that will be used in internal maps and sets. Absent
it, the parser itself will be used. It may be possible to
get better performance by using an integer, for example than
an object.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.runParser">
				<div class="function-name">
					<b>runParser</b> <b>::</b> Parser t a &#8594; [t] &#8594; int &#8594; LeftRecContext &#8594; State ParseState (Either ParseError (ParseResult a))
				</div>
				<div class="function-desc">
					
Runs the parser on the provided input, at the provided position, given
the provided LeftRecContext (left recursion depth map).<br><br>Returns a State monad value that can be applied to the current (including initial)
ParseState to get the parser's result.<br><br>Note: This is used internally. Use Parser.runParser to run the outermost parser for
your grammar. Doing so will also run the State monad, allowing you to inspect the results.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.Parser">
				<div class="function-name">
					<b>Parser</b> <b>::</b> ([t] &#8594; int &#8594; LeftRecContext &#8594; State ParseState (Either ParserError (ParseResult a))) &#8594; Parser t a
				</div>
				<div class="function-desc">
					
Constructs a Parser from the provided function.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.of/unit">
				<div class="function-name">
					<b>of/unit</b> <b>::</b> a &#8594; Parser t a
				</div>
				<div class="function-desc">
					
Returns a parser whose result is the value
provided (always). This parser always succeeds
without consuming any input.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.empty">
				<div class="function-name">
					<b>empty</b> <b>::</b> Parser t ()
				</div>
				<div class="function-desc">
					
A parser with no result. This parser always succeeds
without consuming any input.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.zero">
				<div class="function-name">
					<b>zero</b> <b>::</b> () &#8594; Parser t ()
				</div>
				<div class="function-desc">
					
Constant function returning the empty parser.<br><br>Exists for fantasy-land compatability.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.getlrec">
				<div class="function-name">
					<b>getlrec</b> <b>::</b> LefRecContext &#8594; int &#8594; int &#8594; LeftRecContext
				</div>
				<div class="function-desc">
					
Returns the LeftRecContext that should be used:<br><br>If the oldPos is not the newPos (in other words,
the prior parser consumed input), then the LeftRecContext
should be reset, otherwise the same one is passed down.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.mergeUps">
				<div class="function-name">
					<b>mergeUps</b> <b>::</b> int &#8594; int &#8594; Set a &#8594; Set a &#8594; Set a
				</div>
				<div class="function-desc">
					
Merges the provided up contexts (sets of parsers
that led to curtailment due to left recursion):<br><br>If oldP is not the newP (some input was consumed
in the second parser), then the first context is
returned. Otherwise, the contexts are merged.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.pruneContext">
				<div class="function-name">
					<b>pruneContext</b> <b>::</b> Set (Parser t any) &#8594; Map (Parser t any) int &#8594; Map (Parser t any) int
				</div>
				<div class="function-desc">
					
Removes entries from the provided LeftRecContext that do not appear
in the cutailment set.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.lookup">
				<div class="function-name">
					<b>lookup</b> <b>::</b> Parser t a &#8594; int &#8594; LeftRecContext &#8594; Map (Parser t a) (Map int (Either ParseError [(ParseResult a), LeftRecContext])) &#8594; ParseResult a | null
				</div>
				<div class="function-desc">
					
Tries to find a valid result in the memoization table for the provided
parser.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.canReuse">
				<div class="function-name">
					<b>canReuse</b> <b>::</b> LeftRecContext &#8594; LeftRecContext &#8594; bool
				</div>
				<div class="function-desc">
					
Checks whether a result can be reused in the current
parsing context.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.cons">
				<div class="function-name">
					<b>cons</b> <b>::</b> a &#8594; [a] &#8594; [a]
				</div>
				<div class="function-desc">
					
Contructs a list from a head element
and a tail list.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.ParseResult">
				<div class="function-name">
					<b>ParseResult</b> <b>::</b> int &#8594; a &#8594; ParseResult a
				</div>
				<div class="function-desc">
					
Returns a ParseResult, representing a parse
that has consumed tokens up to (p - 1) and
has yielded the value x.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.Succeed">
				<div class="function-name">
					<b>Succeed</b> <b>::</b> int &#8594; a &#8594; Either ParseError (ParseResult a)
				</div>
				<div class="function-desc">
					
See ParseResult. Applies ParseResult to p, x and then
wraps the return value in an Either context.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.ParseError">
				<div class="function-name">
					<b>ParseError</b> <b>::</b> int &#8594; Error &#8594; ParseError
				</div>
				<div class="function-desc">
					
Returns a ParseError, representing a parse
that failed after consuming tokens up to (p - 1)
with the provided error.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.Fail">
				<div class="function-name">
					<b>Fail</b> <b>::</b> int &#8594; Error &#8594; ParseError
				</div>
				<div class="function-desc">
					
See ParseError. Applies ParseError to p, e and then
wraps the return value in an Either context.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.stringTerm">
				<div class="function-name">
					<b>stringTerm</b> <b>::</b> string &#8594; Parser string string
				</div>
				<div class="function-desc">
					
Recognizes the provided term.<br><br>Can be thought of as a CFG terminal.<br><br>Aliases: term
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.regexTerm">
				<div class="function-name">
					<b>regexTerm</b> <b>::</b> RegExp &#8594; string &#8594; Parser string [string]
				</div>
				<div class="function-desc">
					
Recognizes strings in the input matching
the provided regular expression. The result
when successful is a list of matches, which
is what is returned by the JavaScript string
match function.<br><br>Aliases: regex
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.tokenTerm">
				<div class="function-name">
					<b>tokenTerm</b> <b>::</b> (t &#8594; bool) &#8594; Parser t t
				</div>
				<div class="function-desc">
					
Recognizes tokens in the input which the
provided predicate returns true for. The
matching token is returned when successful.<br><br>This is useful when you perform lexical analysis
separately from parsing, as you cannot use the
string or regex terminal parsers on tokens (obviously).<br><br>Aliases: token
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.recursive">
				<div class="function-name">
					<b>recursive</b> <b>::</b> (() &#8594; Parser t a) &#8594; Parser t a
				</div>
				<div class="function-desc">
					
Creates a Parser that applies the provided
function the first time the parser is used to get
a parser to parse with. That parser is then used
to parse the current and all subsequent inputs when
the returned parser is used.<br><br>This allows the construction of recursive grammars,
so that parsers can refer to ones that have not
yet been defined.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.findToken">
				<div class="function-name">
					<b>findToken</b> <b>::</b> (t &#8594; bool) &#8594; string &#8594; Parser t t
				</div>
				<div class="function-desc">
					
Returns a parser that consumes input until it matches
an input token with the provided predicate. If no match
occurs, then an error is raised.<br><br>This is useful in conjunction with lookahead when
parsing input that has been lexed. For raw input, regex
is probably more useful.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.lookahead">
				<div class="function-name">
					<b>lookahead</b> <b>::</b> Parser t a &#8594; Parser t bool
				</div>
				<div class="function-desc">
					
Returns a parser that will check if the
provided parser matches the upcoming input.<br><br>If it does, true is returned, otherwise false
is returned. The resulting parser does not
consume input.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.any">
				<div class="function-name">
					<b>any</b> <b>::</b> Parser t t
				</div>
				<div class="function-desc">
					
A parser that will consume the next token of input
and return it as its result, no matter what it is.<br><br>If there is no input left, then an error is returned.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.all">
				<div class="function-name">
					<b>all</b> <b>::</b> Parser t [t]
				</div>
				<div class="function-desc">
					
A parser that will consume any remaining input.<br><br>It is not an error to already be at the end of the input,
but an empty result will be returned if this is the case.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.eof">
				<div class="function-name">
					<b>eof</b> <b>::</b> Parser t ()
				</div>
				<div class="function-desc">
					
A parser that expects to see the end of input.<br><br>If EOF has been reached, then an empty result is returned,
otherwise an error is returned.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.fail">
				<div class="function-name">
					<b>fail</b> <b>::</b> Error &#8594; Parser t ()
				</div>
				<div class="function-desc">
					
Returns a parser that always fails with
the provided error.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.Parser.Parser.func.showError">
				<div class="function-name">
					<b>showError</b> <b>::</b> ParseError &#8594; ([t], int) &#8594; string
				</div>
				<div class="function-desc">
					
Returns a formatted error message from the provided
error.<br><br>The input to the parser should be provided, along with
a context value that determines how much input around the
position where the error ocurred should be shown.
				</div>
			</div>
		
			</div>
		</div>
	
		<div class="module-description" id="doc.module.MonadicJS.State">
			<div class="module-name">
				Module: MonadicJS.State
			</div>
			<div class="module-author">
			<b>Written By:</b> Joel Dentici
			</div>
			<div class="module-date">
			<b>Written On:</b> 7/3/2017
			</div>
			<div class="module-desc">
			The State monad.
			</div>
			<div class="module-functions">
				
			<div class="function-description"
			id="doc.module.MonadicJS.State.func.new">
				<div class="function-name">
					<b>new</b> <b>::</b> (s &#8594; [t, s]) &#8594; State s t
				</div>
				<div class="function-desc">
					
Constructs a new State_ value.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.State.func.runState">
				<div class="function-name">
					<b>runState</b> <b>::</b> State s t &#8594; s &#8594; [t, s]
				</div>
				<div class="function-desc">
					
Runs the state monad with the provided
state.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.State.func.bind">
				<div class="function-name">
					<b>bind</b> <b>::</b> State s a &#8594; (a &#8594; State s b) &#8594; State s b
				</div>
				<div class="function-desc">
					
Monadic bind. The result, when ran, will apply
the function in this State to the provided state
to get a result and updated state. The provided function
is applied to the result to get a new State and the function
in the resulting State is applied to the updated state.<br><br>Thus, the state is threaded through to the provided function
as well as the value.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.State.func.map">
				<div class="function-name">
					<b>map</b> <b>::</b> State s a &#8594; (a &#8594; b) &#8594; State s b
				</div>
				<div class="function-desc">
					
Functor map for State.<br><br>Maps the function over this state by applying
the provided function to the value inside
this state, without affecting the current
state.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.State.func.chain">
				<div class="function-name">
					<b>chain</b> <b>::</b> State s a &#8594; (a &#8594; State s b) &#8594; State s b
				</div>
				<div class="function-desc">
					
Alias for bind. Used for fantasy-land compliance.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.State.func.State">
				<div class="function-name">
					<b>State</b> <b>::</b> (s &#8594; [a, s]) &#8594; State s a
				</div>
				<div class="function-desc">
					
Constructs a State from a state threading
computation.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.State.func.unit/of">
				<div class="function-name">
					<b>unit/of</b> <b>::</b> a &#8594; State s a
				</div>
				<div class="function-desc">
					
Puts a value into a stateful context.<br><br>Does not change the state.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.State.func.get">
				<div class="function-name">
					<b>get</b> <b>::</b> State s s
				</div>
				<div class="function-desc">
					
Returns a new State whose computation
returns the provided state as its value,
and leaves the state unchanged.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.State.func.put">
				<div class="function-name">
					<b>put</b> <b>::</b> s &#8594; State s ()
				</div>
				<div class="function-desc">
					
Returns a new State whose computation
replaces the current state with the
state provided to put.
				</div>
			</div>
		
			<div class="function-description"
			id="doc.module.MonadicJS.State.func.modify">
				<div class="function-name">
					<b>modify</b> <b>::</b> (s &#8594; s) &#8594; State s ()
				</div>
				<div class="function-desc">
					
Returns a new State whose computation
applies the provided transformation to
the current state and returns that as
the new state.
				</div>
			</div>
		
			</div>
		</div>
	
			</div>

			<div class="top-scroll">
					<a href="#top">&#8593;</a>
			</div>

			<div class="footer">
			This documentation was generated by <code>hmdoc</code> on <code>7/14/2017, 9:46:37 PM</code>
			</div>
		</body>
	</html>
	
