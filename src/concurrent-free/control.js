const CaseClass = require('../utility.js').CaseClass;
const F = require('./index.js');
const Async = require('../async');

/**
 *	MonadicJS.ConcurrentFree.Control
 *	written by Joel Dentici
 *	on 7/20/2017
 *
 *	Provides control flow primitives for Free monads
 *	that require access to execution.
 *
 *	Note that this is what gives ConcurrentFree its Alternative
 *	instance, so you must include it in your interpreter list to use
 *	Alternative composition with ConcurrentFree.
 */

class Try extends CaseClass {
	constructor(op, handler) {
		super();
		this.op = op;
		this.handler = handler;
	}

	doCase(fn) {
		return fn(this.op, this.handler);
	}
}

class ThrowE extends CaseClass {
	constructor(err) {
		super();
		this.err = err;
	}

	doCase(fn) {
		return fn(this.err);
	}
}

class FromAsync extends CaseClass {
	constructor(async) {
		super();
		this.async = async;
	}

	doCase(fn) {
		return fn(this.async);
	}
}

class Delay extends CaseClass {
	doCase(fn) {
		return fn();
	}
}

/**
 *	catch e a :: Object
 *
 *	A catch is an object providing a catch method
 *	that accepts a handler for errors.
 *
 *	<code>catch :: () -> (e -> Free Control a) -> Free Control a</code>
 *
 *	You don't need to supply your own catch. It is what is
 *	returned by applying tryF. You supply a handler to that
 *	catch. This is purely so try-catch looks like normal JS.
 */

/**
 *	tryF :: Free f a -> catch e b -> Free Control (a | b)
 *
 *	Applying tryF to a Free Monad value will return
 *	a catch that accepts a handler for the errors that
 *	may be generated by interpreting that Free Monad value.
 *
 *	The result of applying the catch to a handler is a Free Monad
 *	whose result type is either the type of this Free Monad or the
 *	type of the Free Monad returned by the handler.
 *
 *	Returning a catch is purely so that this looks like normal JS.
 */
const tryF = op => ({
	catch: handler => F.liftF(new Try(op, handler))
});

/**
 *	throwE :: e -> Free Control ()
 *
 *	Throws an error.
 */
const throwE = err => F.liftF(new ThrowE(err));

/**
 *	fromAsync :: Async c e a -> Free Control a
 *
 *	Useful if you will be interpreting to Async.
 *
 *	When interpreted into an Async, it just spits out
 *	the Async it is holding
 */
const fromAsync = async => F.liftF(new FromAsync(async));

/**
 *	delay :: Free Control ()
 *
 *	Represents a delay in further computation.
 *
 *	This can be useful at the beginning of a Free program
 *	to force waiting before executing the first statement,
 *	which might be a plain old JS statement with a side effect
 *	that we did not intend to run yet. It is unimportant for
 *	"pure" side effects that occur in a monad.
 *
 *	We can't get this from just using F.of since we immediately
 *	apply the chained function.
 */
const delay = F.liftF(new Delay());

/**
 *	fromPromise :: Promise e a -> Free Control a
 *
 *	Wraps the promise in an Async and then applies
 *	fromAsync to that.
 */
const fromPromise = promise => fromAsync(Async.fromPromise(promise));

class Interpreter {
	constructor() {}

	setup() {
		return Async.of();
	}

	transform(v, transformations) {
		return v.case({
			Try: (op, handler) => {
				const comp1 = op.foldConcurrent(Async, transformations);

				const comp2 = comp1.catch(e => 
					handler(e).foldConcurrent(Async, transformations));

				return comp2;
			},
			ThrowE: err => Async.fail(err),
			FromAsync: async => async,
			Delay: _ => Async.of(),
			default: () => {},
		});
	}

	cleanupSuccess() {
		return Async.of();
	}

	cleanupFail() {
		return Async.of();
	}
}

const interpreter = () => new Interpreter();

module.exports = {
	interpreter,
	tryF,
	throwE,
	fromAsync,
	fromPromise,
	delay
};